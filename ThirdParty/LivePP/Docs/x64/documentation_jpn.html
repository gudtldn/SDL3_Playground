<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keywords" content="">

    <title>Live++ for Windows - ドキュメンテーション</title>

    <!-- Style -->
    <link href="assets/css/docs.css" rel="stylesheet">

    <!-- Fonts -->
    <link href="assets/css/fonts.css" rel="stylesheet">

    <!-- Favicons -->
    <link rel="icon" href="assets/img/favicon.png">
    <link rel="shortcut icon" href="favicon.ico">
</head>
<body>
    <div class="header">
        <div class="header-left">
            <img src="assets/img/logo.svg" alt="Live++ logo" width="48" height="48"/>
            <span>Live++ for Windows - ドキュメンテーション</span>
        </div>
        <div class="header-right">
            <a href="./documentation.html">English</a>
            <a href="./documentation_jpn.html">日本語</a>
            <a href="./documentation_zho.html">한국어</a>
            <a href="./documentation_kor.html">简体中文</a>
        </div>
    </div>

    <div class="main-container">
        <div class="nav-container">
        <nav>
          <ul>
            <li>
             <a href="#quickstart_guide">クイックスタートガイド</a>             <ul>
                <li><a href="#examples">使用例</a></li>
              </ul>
            </li>
            <li>
             <a href="#installation">インストール</a>             <ul>
                <li><a href="#directory_structure">ディレクトリ構造</a></li>
              </ul>
            </li>
            <li>
             <a href="#architecture">アーキテクチャ</a>             <ul>
                <li><a href="#broker">Broker</a></li>
                <li><a href="#agent">Agent</a></li>
                <li><a href="#bridge">Bridge</a></li>
                <li><a href="#communication">通信</a></li>
              </ul>
            </li>
            <li>
             <a href="#project_setup">プロジェクトの設定</a>             <ul>
                <li><a href="#compiler_settings">コンパイラ設定</a></li>
                <ul>
                  <li><a href="#compiler_settings_MSVC">MSVC/Visual Studio</a></li>
                </ul>
                <ul>
                  <li><a href="#compiler_settings_clang_cl">Clang-cl</a></li>
                </ul>
                <ul>
                  <li><a href="#compiler_settings_clang++">Clang++</a></li>
                </ul>
                <li><a href="#linker_settings">リンカの設定</a></li>
                <ul>
                  <li><a href="#linker_settings_MSVC">MSVC/Visual Studio</a></li>
                </ul>
                <ul>
                  <li><a href="#linker_settings_lld_link">lld-link</a></li>
                </ul>
                <li><a href="#incompatible_settings">互換性のない設定</a></li>
                <li><a href="#required_files">必須ファイル</a></li>
                <li><a href="#supported_setups">サポートされる設定</a></li>
                <ul>
                  <li><a href="#FASTBuild">FASTBuild</a></li>
                  <li><a href="#IncrediBuild">Incredibuild</a></li>
                  <li><a href="#distributed_builds">分散ビルド</a></li>
                </ul>
              </ul>
            </li>
            <li>
             <a href="#usage">使用方法</a>           <ul>                
                <li><a href="#usage_agents">エージェント</a></li>
                <ul>
                  <li><a href="#creating_default_agent">デフォルトエージェントの作成</a></li>
                  <li><a href="#creating_synchronized_agent">同期エージェントの作成</a></li>
                </ul>
                <li><a href="#enabling_livepp">Live++の有効化</a></li>
                <li><a href="#dynamically_loaded_modules">動的にロードされるモジュール</a></li>
              </ul>
            </li>
            <li>
             <a href="#tools">ツール</a>        <ul>
                <li><a href="#tools_hot_reload">ホットリロード</a></li>
                <ul>
                  <li><a href="#unity_file_splitting">ユニティ分割</a></li>
                  <li><a href="#halted_processes">停止したプロセス</a></li>
                  <li><a href="#natvis_visualizations">Natvisビジュアライゼーション</a></li>
                </ul>
                <li><a href="#tools_hot_restart">ホットリスタート</a></li>
                <ul>
                  <li><a href="#hot_restart_request">ホットリスタートのリクエスト</a></li>
                  <li><a href="#hot_restart_default_agents">デフォルトエージェント</a></li>
                  <li><a href="#hot_restart_synchronized_agents">同期エージェント</a></li>
                </ul>
                <li><a href="#tools_hot_fix">ホットフィックス</a></li>
                <li><a href="#tools_hot_deoptimize">ホットデ最適化</a></li>

                <li><a href="#multi_process_editing">マルチプロセス編集</a></li>
                <li><a href="#networked_editing">ネットワーク編集</a></li>
              </ul>
            </li>
            <li>
             <a href="#licensing">ライセンス</a>             <ul>
                <li><a href="#licensing_activation">アクティベーション</a></li>
                <li><a href="#licensing_deactivation">無効化</a></li>
                <li><a href="#licensing_trial">無料トライアル</a></li>
                <li><a href="#licensing_command_line_tools">コマンドラインツール</a></li>
              </ul>
            </li>
            <li>
             <a href="#gui">GUI</a>  <ul>
                <li><a href="#gui_views_targets">ターゲット</a></li>
                <li><a href="#gui_views_processes">処理</a></li>
                <li><a href="#gui_views_modules">モジュール</a></li>
                <li><a href="#gui_views_compilands">コンパイル単位</a></li>
              </ul>
            </li>
            <li>
             <a href="#global_preferences">グローバル環境設定</a>             <ul>
                <li><a href="#global_preferences_ui">UI</a></li>
                <li><a href="#global_preferences_logging">ロギング</a></li>
                <li><a href="#global_preferences_network">ネットワーク</a></li>
                <li><a href="#global_preferences_notifications">通知</a></li>
                <li><a href="#global_preferences_hot_reload">ホットリロード</a></li>
                <li><a href="#global_preferences_hot_restart">ホットリスタート</a></li>
                <li><a href="#global_preferences_ide">IDE</a></li>
                <li><a href="#global_preferences_licensing">ライセンス</a></li>
              </ul>
            </li>
            <li>
             <a href="#project_preferences">プロジェクト環境設定</a>             <ul>
                <li><a href="#project_preferences_general">一般設定</a></li>
                <li><a href="#project_preferences_hot_reload">ホットリロード</a></li>
                <li><a href="#project_preferences_compiler">コンパイラ</a></li>
                <li><a href="#project_preferences_linker">リンカ</a></li>
                <li><a href="#project_preferences_exceptions">例外</a></li>
                <li><a href="#project_preferences_continuous_compilation">連続コンパイル</a></li>
                <li><a href="#project_preferences_virtual_drive">仮想ドライブ</a></li>
                <li><a href="#project_preferences_unity_splitting">ユニティ分割</a></li>
              </ul>
            </li>
            <li>
             <a href="#API">API</a>  <ul>
                <li><a href="#API_naming_convention">命名規則</a></li>
                <li><a href="#API_flavours">フレーバー</a></li>
                <li><a href="#API_versioning">バージョン管理</a></li>
                <li><a href="#API_agent_validation">エージェントの検証</a></li>
                <li><a href="#API_connection_callback">接続コールバック</a></li>
                <li><a href="#API_hooks">フック</a></li>
                <ul>
                  <li><a href="#API_compile_hooks">コンパイルフック</a></li>
                  <li><a href="#API_link_hooks">リンクフック</a></li>
                  <li><a href="#API_hot_reload_hooks">ホットリロードフック</a></li>
                  <li><a href="#API_global_hot_reload_hooks">グローバルホットリロードフック</a></li>
                </ul>
                <li><a href="#API_structural_change">構造の変更</a></li>
                <li><a href="#API_applying_preferences">環境設定の適用</a></li>
                <li><a href="#API_logging_to_the_UI">UIへのログ記録</a></li>
              </ul>
            </li>
            <li>
            </li>
            <li>
             <a href="#limitations">制限事項</a>           <ul>
                <li><a href="#limitation_overhead">オーバーヘッド</a></li>
                <li><a href="#limitation_breakpoints">Visual Studioでのブレークポイント</a></li>
                <li><a href="#limitation_global_variables">デバッガでのグローバル変数</a></li>
                <li><a href="#limitation_functions_on_the_stack">スタック上の関数</a></li>
                <li><a href="#limitation_thread_local_storage">スレッドローカルストレージ</a></li>
                <li><a href="#limitation_clang_dynamic_initializers">Clangの動的イニシャライザ</a></li>
              </ul>
            </li>
            <li>
             <a href="#known_issues">既知の問題</a>             <ul>
                <li><a href="#known_fastbuild_clang">Clang++ での FASTBuild</a></li>
                <li><a href="#known_issues_external">'/external:I' には '/external:W' が必要です。</a></li>
                <li><a href="#known_issues_include">PDB で INCLUDE が見つからない</a></li>
                <li><a href="#known_reloading_in_halted_processes">停止中のプロセスでのホット・リロード</a></li>
              </ul>
            </li>
            <li>
             <a href="#troubleshooting">トラブルシューティング</a>             <ul>
                <li><a href="#troubleshooting_missing_compilands">コンパイルランドの欠落</a></li>
                <li><a href="#troubleshooting_verbose_compiling">冗長なコンパイル</a></li>
                <li><a href="#troubleshooting_verbose_linking">冗長なリンク</a></li>
              </ul>
            </li>
            <li>
             <a href="#3rd_party_libraries">サードパーティライブラリ</a>           </li>
          </ul>
            </nav>
        </div>

        <main class="content">
          <header>
            <h1 id="quickstart_guide"><a href="#quickstart_guide">クイックスタートガイド</a></h1>
            <p class="lead">Live++をプロジェクトの一つですぐに試して、後で詳細を処理したい場合は、以下のステップに従ってください：</p>
            <ol>
              <li><strong>LivePP</strong>フォルダがプロジェクト階層内の場所に保存されていることを確認してください。</li>
              <li>プロジェクトの<a href="#compiler_settings">コンパイラ・オプションと</a> <a href="#linker_settings">リンカ・オプションを</a>設定します。</li>
              <li>デフォルトAgentを作成し、以下のコードを使用して、ロードされたすべてのモジュールに対してLive++を有効にします：</li>

<pre class="notranslate"><code class="language-cpp"><span class="token comment" spellcheck="true">// include the API for Windows, 64-bit, C++</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"LivePP/API/x64/LPP_API_x64_CPP.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// create a default agent, loading the Live++ agent from the given path, e.g. "ThirdParty/LivePP"</span>
  lpp<span class="token operator">::</span>LppDefaultAgent lppAgent <span class="token operator">=</span> lpp<span class="token operator">::</span><span class="token function">LppCreateDefaultAgent</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span> absoluteOrRelativePathWithoutTrailingSlash<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// bail out in case the agent is not valid</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lpp<span class="token operator">::</span><span class="token function">LppIsValidDefaultAgent</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lppAgent<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// enable Live++ for all loaded modules</span>
  lppAgent<span class="token punctuation">.</span><span class="token function">EnableModule</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span><span class="token function">LppGetCurrentModulePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lpp<span class="token operator">::</span>LPP_MODULES_OPTION_ALL_IMPORT_MODULES<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// run the application</span>
  <span class="token comment" spellcheck="true">// ...</span>
  Application<span class="token operator">::</span><span class="token function">Exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// destroy the Live++ agent</span>
  lpp<span class="token operator">::</span><span class="token function">LppDestroyDefaultAgent</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lppAgent<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
              <li>アプリケーションを起動し、選択したアプリケーションでソース・ファイルを変更し、変更を保存して、<kbd class="notranslate">ctrl + alt + F11</kbd> 、Live++ホット・リロードを起動します。</li>
            </ol>
          </header>

          <section>
            <h2 id="examples"><a href="#examples">例</a></h2>
            <p class="lead">あるいは、Live++に同梱されているサンプル（<a href="../../releases.html" target="_blank">別個のダウンロードとして</a>入手可能）を見てください。これらのサンプルには、Visual Studio 2017、2019、および2022用の既製のソリューションとプロジェクトが付属しており、Live++が提供するさまざまな機能を実演しているため、自分で何もセットアップすることなく実験することができます。</p>
          </section>

          <header>
            <h1 id="installation"><a href="#installation">インストール</a></h1>
            <p class="lead">Live++は、長いインストールプロセスを必要としません。ディレクトリツリー全体をハードドライブ上の任意の場所にコピーするだけです。もちろん、プロジェクトの管理に使用しているバージョン管理システムに、Live++フォルダをアップロードすることもできます。</p>
          </header>

          <section>
            <h2 id="directory_structure"><a href="#directory_structure">ディレクトリ構造</a></h2>
            <p>Live++ビルドのディレクトリ構造の例です：</p>
            <div class="notranslate file-tree">
              <ul>
                <li class="is-folder open">
                  LivePP<i>メインの Live++ フォルダー</i>
                  <ul>
                    <li class="is-folder open">
                      Agent<i>ターゲット アプリケーションにロードされたエージェント</i>
                      <ul>
                        <li class="is-folder open">
                          x64<i>Windows、64ビット用エージェント</i>
                          <ul>
                            <li class="is-file">LPP_Agent_Bridge_x64.exe<i>AgentとBroker間の通信用ヘルパープロセス</i></li>
                            <li class="is-file">LPP_Agent_Bridge_x64.pdb<i>デバッグシンボルを含むパブリックPDB</i></li>
                            <li class="is-file">LPP_Agent_x64_CPP.dll<i>Windows用Agent、64ビット、C++。</i></li>
                            <li class="is-file">LPP_Agent_x64_CPP.pdb<i>デバッグシンボルを含む公開PDB</i></li>
                            <li class="is-file">LPP_Agent_x86_CPP.dll<i>Windows用Agent、32ビット、C++。</i></li>
                            <li class="is-file">LPP_Agent_x86_CPP.pdb<i>デバッグシンボルを含む公開PDB</i></li>
                          </ul>
                        </li>
                      </ul>
                    </li>

                    <li class="is-folder open">
                     API<i>API異なるプラットフォームと言語用の</i>
                     <ul>
                        <li class="is-folder open">
                          x64<i>Windows 用 API、64 ビット</i>
                          <ul>
                            <li class="is-file"><strong>LPP_API_x64_CPP.h</strong><i>Windows、64ビット、C++をサポートするためのプラットフォーム固有のヘッダーファイル</i></li>
                            <li class="is-file">LPP_API.h<i>プラットフォーム固有のAPIファイルで使用されるメインAPIヘッダファイル (クライアントによってインクルードされることはありません)</i></li>
                            <li class="is-file">LPP_API_Helpers.h<i>プラットフォーム固有の API ファイルで使用される補助ヘッダーファイル (クライアントによってインクルードされることはありません)</i></li>
                            <li class="is-file">LPP_API_Hooks.h<i>プラットフォーム固有の API ファイルで使用される補助ヘッダファイル (クライアントによってインクルードされることはありません)</i></li>
                            <li class="is-file">LPP_API_Options.h<i>プラットフォーム固有の API ファイルで使用される補助ヘッダファイル (クライアントによってインクルードされることはありません)</i></li>
                            <li class="is-file">LPP_API_Preferences.h<i>プラットフォーム固有の API ファイルで使用される補助ヘッダーファイル (クライアントによってインクルードされることはありません)</i></li>
                            <li class="is-file">LPP_API_Version_x64_CPP.h<i>プラットフォーム固有の API ファイルで使用される補助ヘッダーファイル (クライアントによってインクルードされることはありません)</i></li>
                            <li class="is-file">version_x64_CPP.txt<i>Windows、64ビット、C++用のバージョン管理ファイル</i></li>
                          </ul>
                        </li>
                      </ul>
                    </li>

                    <li class="is-folder open">
                      Broker
                      <ul>
                        <li class="is-folder open">
                          Plugins<i>さまざまなプラットフォームと言語用のプラグイン</i>
                          <ul>
                            <li class="is-file">LPP_Broker_x64_CPP.dll<i>Windows、64ビット、C++対応プラグイン</i></li>
                            <li class="is-file">LPP_Broker_x64_CPP.pdb<i>デバッグシンボルを含む公開PDB</i></li>
                            <li class="is-file">LPP_Weak_Symbols_x64_CPP.obj<i>Windows、64ビット、C++をサポートする弱いシンボルのヘルパーファイル</i></li>
                            <li class="is-file">LPP_Weak_Symbols_x86_CPP.obj<i>Windows、32ビット、C++をサポートする弱いシンボルのヘルパーファイル</i></li>
                          </ul>
                        </li>
                        <li class="is-file">dbghelp.dll<i>Brokerが使用する64ビットヘルパDLL</i></li>
                        <li class="is-file">LPP_Broker.exe<i>メインLive++ Brokerアプリケーション</i></li>
                        <li class="is-file">LPP_Broker.pdb<i>デバッグ・シンボルを含むパブリックPDB</i></li>
                        <li class="is-file">srcsrv.dll<i>Brokerが使用する64ビットヘルパDLL</i></li>
                        <li class="is-file">symsrv.dll<i>Brokerが使用する64ビットヘルパDLL</i></li>
                      </ul>
                    </li>

                    <li class="is-folder open">
                      CLI<i>コマンドラインツール</i>
                      <ul>
                        <li class="is-file">LPP_License_x64_CPP.exe<i>Windows、64 ビット、C++ のライセンスのアクティブ化と非アクティブ化を許可します。</i></li>
                        <li class="is-file">LPP_License_x64_CPP.pdb<i>デバッグシンボルを含むパブリックPDB</i></li>
                      </ul>
                    </li>

                    <li class="is-folder closed">
                      Docs<i>このドキュメント</i>
                      <ul>
                      </ul>
                    </li>

                    <li class="is-folder open">
                      EULA
                      <ul>
                        <li class="is-file">LPP_EULA.pdf<i>エンドユーザーライセンス契約書</i></li>
                      </ul>
                    </li>
                  </ul>
                </li>

                <li class="is-folder open">
                  Examples_x64
                  <ul>
                    <li class="is-folder closed">
                      build<i>Visual Studio 2017、2019、2022のソリューションとプロジェクト</i>
                      <ul>
                      </ul>
                    </li>

                    <li class="is-folder closed">
                    FASTBuild<i>FASTBuild</i>
                      <ul>
                      </ul>
                    </li>

                    <li class="is-folder closed">
                      LLVM<i>clang-cl および lld-link</i>
                      <ul>
                      </ul>
                    </li>

                    <li class="is-folder closed">
                      readme<i>READMEサンプルについて説明したファイル</i>
                      <ul>
                      </ul>
                    </li>

                    <li class="is-folder closed">
                      src<i>C++サンプルで使用されているソースコード</i>
                      <ul>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </div>
          </section>

          <header>
            <h1 id="architecture"><a href="#architecture">アーキテクチャ</a></h1>
            <p class="lead">ターゲット・アプリケーションへの影響をできるだけ抑え、ネットワーク・ホット・リロードなどの機能を実現するため、Live++はいくつかのプロセスとモジュールに分割されています。</p>
          </header>

          <section>
            <h2 id="broker"><a href="#broker">Broker</a></h2>
            <p>Brokerは、Live++のメイン・アプリケーション・プロセスです。Live++のAgentが接続するサーバーとして動作します。Brokerは、一度起動すれば、ずっと実行し続けることができる長時間実行アプリケーションです。ターゲット アプリケーションを閉じたり、再度開いたりするたびに、Brokerを再起動する必要はありません。さらに、Brokerは、.pdbや.obj形式のファイルなど、Live++に必要なファイルの内部キャッシュを保存するため、アプリケーションの一部だけが再起動の間に変更された場合のロード時間が大幅に改善されます。</p>
            <p>ローカル接続の場合、Live++ Agentがターゲット アプリケーションにロードされると同時に、Brokerが自動的に起動します。</p>

            <p>Brokerは特定のポートで着信接続をリッスンするサーバーとして動作するため、複数のBrokerを同時に実行できるのは、各Brokerが異なるポートを通信に使用する場合に限られます。</p>

            <h2 id="agent"><a href="#agent">Agent</a></h2>
            <p>AgentはBrokerまたはBridgeから指示されたタスクを実行します。エージェントは、小さな共有ライブラリ（Windows と Xbox の .dllなど）として出荷され、対応する API を通して利用可能なエージェントのいずれかを作成する際に、ターゲットアプリケーションにロードされます。</p>
            <p>このアプローチにより、<a href="https://docs.unity3d.com/Manual/NativePlugins.html" target="_blank">Unity Nativeプラグイン</a>、<a href="https://help.autodesk.com/view/MAYAUL/2022/ENU/?guid=Maya_SDK_A_First_Plugin_cpp_HelloWorldComplete_html" target="_blank">Autodesk Mayaプラグインなど</a>、Live++について何も知らず、ホットリロード機能が組み込まれていないアプリケーションであっても、完全に任意のターゲットアプリケーションにロードされるモジュールでLive++を使用することが可能になります。</p>

            <div class="callout callout-info-MM" role="alert">
              <h4>例</h4>
              <p>Live++には、これを示す<strong>"13_ArbitraryTarget"</strong>というサンプルが同梱されています。</p>
            </div>

            <h2 id="bridge"><a href="#bridge">Bridge</a></h2>
            <p>特定のプラットフォーム（WindowsやXboxなど）では、BridgeはAgentとBrokerの間の中間プロセスとして機能し、Brokerは必ずしもAgentと同じマシン上で実行されないため、ネットワークホットリロードなどの機能を提供するために必要です。しかし、Bridgeはユーザにとって完全に透過的でなければなりません。</p>

            <h2 id="communication"><a href="#communication">通信</a></h2>
            <p>Agent と Bridge は常に同じマシン上で動作するため、互いに Named Duplex Pipes を介して通信します。</p>
            <p>Bridge と Broker は、<a href="#global_preferences_network">グローバル環境</a>設定で設定したホスト名または IP アドレスを使用して、ポート 12216 で TCP/IP 経由で互いに通信します。</p>
          </section>

          <header>
            <h1 id="project_setup"><a href="#project_setup">プロジェクトのセットアップ</a></h1>
            <p class="lead">Live++は、いくつかのコンパイラとリンカの設定を除いて、特別なプロジェクト・セットアップを必要としません。プロジェクトやソリューションで、スタティック・ライブラリ（.lib）とダイナミック・ライブラリ（.dll）を組み合わせて使用してもまったく問題ありません。Live++は、関係するすべてのオブジェクト・ファイルと実行可能ファイルから、必要な情報を自動的に抽出します。</p>
          </header>
            
          <section>
            <h2 id="compiler_settings"><a href="#compiler_settings">コンパイラ設定</a></h2>
            <h3 id="compiler_settings_MSVC"><a href="#compiler_settings_MSVC">MSVC/Visual Studio</a></h3>
            <p>Live++を使用する各プロジェクトの構成プロパティで、これらのコンパイラ設定を有効にする必要があります：</p>
            <p><span class="notranslate label label-default label-custom-MM">C/C++ -&gt; General -&gt; Debug Information Format</span>、<span class="notranslate label label-default-MM label-custom-MM">C7 compatible (/Z7)</span>または<span class="notranslate label label-default-MM label-custom-MM">Program Database (/Zi)</span>に設定する必要があります。</p>
            <p><span class="notranslate label label-default label-custom-MM">C/C++ -&gt; Code Generation -&gt; Enable Minimal Rebuild</span>を<span class="notranslate label label-default-MM label-custom-MM">No (/Gm-)</span>設定する必要があります。</p>

            <p>x86/Win32プロジェクトでは、さらに以下のコンパイラ設定が必要です：</p>
            <p><span class="notranslate label label-default label-custom-MM">C/C++ -&gt; Code Generation -&gt; Create Hotpatchable Image</span>を<span class="notranslate label label-default-MM label-custom-MM">Yes (/hotpatch)</span>に設定する必要があります。</p>

            <div class="callout callout-info-MM" role="alert">
              <h4>注</h4>
              <p>厳密には必要ではありませんが、パッチの実行ファイルとPDBをできるだけ小さくするために、<a href="https://docs.microsoft.com/en-us/cpp/build/reference/gy-enable-function-level-linking" target="_blank">/Gy (Enable Function-Level Linking)</a>と<a href="https://docs.microsoft.com/en-us/cpp/build/reference/gw-optimize-global-data" target="_blank">/Gw (Optimize Global Data)</a>の両方のコンパイラーオプションを使用することをお勧めします。</p>
            </div>

            <div class="callout callout-info-MM" role="alert">
              <h4>ヒント</h4>
              <p>Visual Studio 2022 の最近のバージョン (バージョン 17.11 以降) では、<span class="notranslate label label-default label-custom-MM">Tools -> Options... -> Debugging -> General -> Enable Hot Reload</span>の下に<span class="notranslate label label-default label-custom-MM">Automatically apply changes on continue (Native only)</span>という新しいオプションが導入されました。これにより、デバッグ中にコードを変更するときに"Hot Reload - Not supported by project"というダイアログが表示されます。 この特定のオプションのみを無効にするか、Visual Studio のホット リロード/エディット コンティニュー機能を完全に無効にすることをお勧めします。
              </p>
            </div>

            <h3 id="compiler_settings_clang_cl"><a href="#compiler_settings_clang_cl">Clang-cl</a></h3>
            <p><strong>clang-clを使って</strong>コンパイルしたコードは、以下のオプションを設定する必要があります：</p>
            <p><span class="notranslate label label-default label-custom-MM">-Z7</span> - オブジェクトファイルのCodeViewデバッグ情報を有効にする。</p>
            <p><span class="notranslate label label-default label-custom-MM">-hotpatch</span> - ホットパッチ可能なイメージを作成します。</p>
            <p><span class="notranslate label label-default label-custom-MM">-Gy</span> - 各関数をそれ自身のセクションに置く</p>
            <p><span class="notranslate label label-default label-custom-MM">-fstandalone-debug</span> - バイナリからデバッグ情報を削除する内部最適化を無効にする。</p>
            <p><span class="notranslate label label-default label-custom-MM">-Xclang -mno-constructor-aliases</span> - コンストラクタとデストラクタを折りたたむ/エイリアスする内部最適化を無効にする。</p>

            <h3 id="compiler_settings_clang++"><a href="#compiler_settings_clang++">Clang++</a></h3>
            <p><strong>clang++は</strong>MSVC/Visual Studioコンパイラオプションを理解しないので、<strong>clang++を使って</strong>コンパイルしたコードには以下のオプションを設定する必要があります：</p>
            <p><span class="notranslate label label-default label-custom-MM">-g</span> - ソースレベルのデバッグ情報を生成する。</p>
            <p><span class="notranslate label label-default label-custom-MM">-g</span> - ソースレベルのデバッグ情報を生成します。</p>
            <p><span class="notranslate label label-default label-custom-MM">-fms-hotpatch</span> - 実行時にすべての関数をホットパッチできるようにします。</p>
            <p><span class="notranslate label label-default label-custom-MM">-ffunction-sections</span> - 各関数を独自のセクションにまとめる</p>
            <p><span class="notranslate label label-default label-custom-MM">-fstandalone-debug</span> - バイナリからデバッグ情報を削除する内部最適化を無効にする。</p>
            <p><span class="notranslate label label-default label-custom-MM">-Xclang -mno-constructor-aliases</span> - コンストラクタとデストラクタを折りたたむ/エイリアスする内部最適化を無効にする。</p>


            <h2 id="linker_settings"><a href="#linker_settings">リンカ設定</a></h2>
            <h3 id="linker_settings_MSVC"><a href="#linker_settings_MSVC">MSVC/Visual Studio</a></h3>
            <p>これらのリンカー設定は、Live++を使用する各プロジェクトの構成プロパティで有効にする必要があります：</p>
            <p><span class="notranslate label label-default label-custom-MM">Linker -> General -> Create Hotpatchable Image</span>は<span class="notranslate label label-default-MM label-custom-MM">Enabled (/FUNCTIONPADMIN)</span>。</p>
            <p><span class="notranslate label label-default label-custom-MM">Linker -> Optimization -> References</span>は<span class="notranslate label label-default-MM label-custom-MM">No (/OPT:NOREF)</span>。</p>
            <p><span class="notranslate label label-default label-custom-MM">Linker -> Optimization -> Enable COMDAT Folding</span>は<span class="notranslate label label-default-MM label-custom-MM">No (/OPT:NOICF)</span>。</p>
            <p><span class="notranslate label label-default label-custom-MM">Linker -> Debugging -> Generate Debug Info</span>は<span class="notranslate label label-default-MM label-custom-MM">Generate Debug Information optimized for sharing and publishing (/DEBUG:FULL)</span>。</p>

            <h3 id="linker_settings_lld_link"><a href="#linker_settings_lld_link">lld-link</a></h3>
            <p><strong>lld-link</strong>は MSVC/Visual Studio のリンカー・オプションと完全に互換性があります。したがって、<strong>lld-link</strong>を使用してリンクされるコードでは、上記と同じオプションを使用する必要があります。</p>

            <div class="callout callout-info-MM" role="alert">
              <h4>例</h4>
              <p>Live++ には、Clang をコンパイラとして使用し、LLD をリンカとして使用する方法を示す<strong>"09_ClangLLD"</strong>というサンプルが同梱されています。</p>
            </div>


            <h2 id="incompatible_settings"><a href="#incompatible_settings">互換性のない設定</a></h2>
            <p>Live++では、コンパイラとリンカのオプションをほとんど自由に組み合わせてコードをビルドできますが、<span class="notranslate label label-default label-custom-MM">C/C++ -&gt; Optimization -&gt; Whole Program Optimization</span>をオンにしたり、Link Time Code Generation（LTCG）やLink Time Optimization（LTO）をオンにしたりすることはサポートされていません。LTCG/LTOを使用して構築されたオブジェクト・ファイルは、サポートされていない独自の形式で情報を保存するため、Live++では使用できません。</p>
            <div class="callout callout-info-MM" role="alert">
              <h4>注記</h4>
              <p>Live++は、互換性のないコンパイラとリンカの設定を自動的に検出し、それに応じてエラーを出力します。</p>
            </div>

            <h2 id="required_files"><a href="#required_files">必須ファイル</a></h2>
            <p>
              モジュールに必要な情報を読み込んで再構築するために、Live++には以下のファイルが必要です：              <ul>
                <li>
                 <strong>すべての Live++ 対応モジュールの PDB ファイル：</strong><br/>PDB ファイルには、実行可能なイメージ・セクション、パブリック・シンボル、関係する翻訳ユニットやツールチェーンに関する有用な情報が含まれています。                </li>
                <li>
                 <strong>Live++対応モジュールにリンクされたオブジェクト・ファイル（.obj）：</strong><br/>Live++が必要とするシンボル情報のほとんどすべてが、オブジェクト・ファイルから抽出され、再構築されます。                </li>
                <li>
                 <strong>上記のオブジェクト・ファイルをコンパイルするために使用されたソース・ファイル（.cpp &amp; .h）</strong>。        </li>
              </ul>
              プロジェクトが、ソースコード（サードパーティのコードなど）やオブジェクトファイル（Visual StudioのCおよびC++ランタイムなど）を持っていないライブラリを使用している場合があります。これは問題ではありません：Live++は対応する翻訳ユニットを無視するだけです。            </p>

            <h2 id="supported_setups"><a href="#supported_setups">サポートされるセットアップ</a></h2>
            <p>
              Live++は、.exe、.dll、および.libプロジェクト、makefileベースのプロジェクト、およびカスタム セットアップとビルド システムを完全にサポートしています。技術的な観点からは、Live++はどのような種類のプロジェクトで使用されるかを気にしません。実際、Live++はプロジェクトの種類をまったく知りません。<br/>とはいえ、プロジェクトの種類が異なると、コーディング・セッションの動作も異なります：              <ul>
                <li>
                 <strong>アプリケーション（.exe）プロジェクト：</strong><br/>Live++は、オリジナルのコンパイラー・コマンドライン・オプションを使用して.objファイルを再コンパイルし、実行プロセスのアドレス空間にロードされるパッチを生成し、既存のシンボルに対してランタイムリンクします。.exeは、2つのLive++セッション間で、ネイティブ・ツールチェーンによって自動的に再コンパイルおよびリンクされます。                </li>
                <li>
                 <strong>ダイナミック・ライブラリ（.dll）プロジェクト：</strong><br/>アプリケーション・プロジェクトと同様に、個々の .obj ファイルが再コンパイルされます。.dllは、セッション間でネイティブツールチェーンによって自動的に再コンパイルおよびリンクされます。                </li>
                <li>
                 <strong>静的ライブラリ（.lib）プロジェクト：</strong><br/>アプリケーション プロジェクトと同様に、.lib ファイルの一部である個々の .obj ファイルは再コンパイルされます。ただし、Live++はこれらの.objファイルを含む静的ライブラリをリンクしません。2 つの Live++ セッションの間に、ネイティブ ツールチェーンは、まず、再コンパイルされたオブジェクト ファイルを含むすべての .lib ファイルをコンパイルおよびリンクし、次に、これらの .lib ファイルを消費するすべてのアプリケーションおよびダイナミック ライブラリを再リンクします。                </li>
                <li>
                 <strong>Makefile ベースのプロジェクト:</strong><br/>makefile の内容に応じて、上記のいずれかと同様です。                </li>
                <li>
                 <strong>カスタムセットアップとビルドシステム:</strong><br/>上記のいずれかと似ていますが、セットアップを使用してビルドされるものに依存します。                </li>
              </ul>
            </p>

            <div class="callout callout-info-MM" role="alert">
              <h4>注</h4>
              <p>Visual Studioに加えて、Live++は<a href="https://www.fastbuild.org/docs/home.html" target="_blank">FASTBuild</a>、<a href="https://www.incredibuild.com/" target="_blank">IncrediBuild</a>、<a href="https://www.snsystems.com/tech-blog/2014/01/06/building-with-the-network/" target="_blank">SN-DBS</a>、さまざまな社内（分散）ビルド・システム、および<a href="https://www.jetbrains.com/clion/download/#section=windows" target="_blank">CLion</a>、<a href="https://www.jetbrains.com/rider/download/#section=windows" target="_blank">Rider</a>、<a href="https://code.visualstudio.com/" target="_blank">Visual Studio Code</a>他のIDEで使用されるビルド・システムでもテストされています。ビルドの構造によっては、Live++が必要なファイルとツールチェーンをすべて検出できるように、最初にいくつかの設定を行う必要があります。</p>
            </div>


            <h3 id="FASTBuild"><a href="#FASTBuild">FASTBuild</a></h3>
            <p>
              FASTBuildをビルド・システムとして使用する場合、特別な設定は必要ありません。            </p>
            <p>
              唯一の例外は、<a href="https://learn.microsoft.com/en-us/cpp/build/reference/fi-name-forced-include-file" target="_blank">/FI コンパイラ・オプションと組み合わせて</a>分散コンパイルを使用する場合です。この場合、FASTBuild は個々の翻訳ユニットをローカルで前処理してからリモート・エージェントに分散しますが、その際に /FI オプションは削除されます。その結果、生成される PDB ファイルから /FI オプションが欠落し、Live++ を使用した再コンパイルに失敗する可能性があります。            </p>
            <p>
              この場合、<a href=#project_preferences_compiler>プロジェクト環境</a>設定で指定できる追加コマンドラインオプションを使って、/FIオプションをLive++に与える必要があります。            </p>

            <div class="callout callout-info-MM" role="alert">
              <h4>例</h4>
              <p>Live++には、これを示す<strong>"11_FASTBuild"</strong>サンプルが同梱されています。</p>
            </div>


            <h3 id="IncrediBuild"><a href="#IncrediBuild">Incredibuild</a></h3>
            <p>
              Incredibuild は、プリコンパイルされたヘッダー・ファイルと一緒に分散ビルドを使 用すると、異なる PDB に対してビルドされた同じプリコンパイルされたヘッダー (例:<strong>C:˶ProjectPCH.pch</strong>)を使用する複数の個別の PDB (例:<strong>C:˶ProjectSourceFile_cpp_ib_1.pdb、 C:˶ProjectSourceFile_cpp_ib_2.pdb、など</strong>)を生成することがあります。厳密に言えば、これはMicrosoftのコンパイラツールチェーンでは許可もサポートもされておらず、再コンパイルしようとするとLive++が<a href="https://docs.microsoft.com/en-us/cpp/error-messages/compiler-errors-2/compiler-error-c2858" target="_blank">エラーC2858を</a>出すことになります。            </p>
            <p>
              この場合、ファイルを再コンパイルするときに、対応するPCHと同じPDBを使用するようにLive++に強制するために、<a href="#project_preferences_compiler">「プリコンパイルされたヘッダーPDBの使用を強制する」</a>設定を使用する必要があります。            </p>


            <h3 id="distributed_builds"><a href="#distributed_builds">分散ビルド</a></h3>
            <p>
              分散コンパイルを使用する場合、ビルド・システムはコンパイラ実行ファイルと必要なすべての補助ファイルをリモート・マシンにコピーし、リモート・マシンでコンパイル・プロセスを開始し、出力をビルドを開始したマシンにコピーして戻します。この場合、Live++がコンパイラとリンカの実行<strong>ファイルを</strong>見つけるために使用する PDB ファイルには、リモート・マシン上のパスが含まれる。            </p>
            <p>
              Live++を使用してファイルを再コンパイルする場合、このパスは使用できないため、<a href="#project_preferences_compiler">「コンパイラ・パスを上書きする」</a>設定を使用し、ローカル・コンパイラが見つかる場所をLive++に伝える必要があります。          
            </p>

            <div class="callout callout-info-MM" role="alert">
              <h4>注意</h4>
              <p>
                これは、<a href="https://www.fastbuild.org/docs/home.html" target="_blank">FASTBuild</a>、<a href="https://www.incredibuild.com/" target="_blank">IncrediBuild</a>、<a href="https://www.snsystems.com/tech-blog/2014/01/06/building-with-the-network/" target="_blank">SN-DBS</a>など、分散/リモート・コンパイルをサポートするすべてのビルド・システムに適用されます。              </p>
            </div>
          </section>

          <header>
            <h1 id="usage"><a href="#usage">使用方法</a></h1>
            <p class="lead">Live++の使用方法は非常に簡単です。実行中のアプリケーションまたはDLLの一部であるソース・ファイルを変更し、変更を保存して、Live++のショートカット<kbd class="notranslate">ctrl + alt + F11</kbd> を押します。</p>
          </header>

          <section>
            <h2 id="usage_agents"><a href="#usage_agents">エージェント</a></h2>
            <p>要件に応じて、現在2種類のエージェントから選択できます。ほとんどのAPIはすべてのエージェントで共有されていますが、細かい制御のための追加APIを提供するエージェントもあります。エージェントは、以下のAPIを使用して作成および破棄できます：</p>

            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>デフォルトエージェントを作成するためのAPI</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="70%" class="notranslate"><strong>
                      <code class=" language-cpp">lpp<span class="token operator">::</span>LppDefaultAgent lpp<span class="token operator">::</span><span class="token function">LppCreateDefaultAgent</span><span class="token punctuation">(</span><span class="token keyword">const</span> LppLocalPreferences<span class="token operator">*</span> <span class="token keyword">const</span> localPreferences<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> absoluteOrRelativePathWithoutTrailingSlash<span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>オプションのローカル環境設定を使用して、デフォルトエージェントを作成します。</td>
                  </tr>

                  <tr>
                    <td width="70%" class="notranslate"><strong>
                      <code class="language-cpp">lpp<span class="token operator">::</span>LppDefaultAgent lpp<span class="token operator">::</span><span class="token function">LppCreateDefaultAgentWithPreferences</span><span class="token punctuation">(</span><span class="token keyword">const</span> LppLocalPreferences<span class="token operator">*</span> <span class="token keyword">const</span> localPreferences<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> absoluteOrRelativePathWithoutTrailingSlash<span class="token punctuation">,</span> <span class="token keyword">const</span> LppProjectPreferences<span class="token operator">*</span> <span class="token keyword">const</span> projectPreferences<span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>指定されたプロジェクト環境設定とオプションのローカル環境設定を使用して、デフォルトエージェントを作成します。</td>
                  </tr>

                  <tr>
                    <td width="70%" class="notranslate"><strong>
                      <code class="language-cpp">lpp<span class="token operator">::</span>LppDefaultAgent lpp<span class="token operator">::</span><span class="token function">LppCreateDefaultAgentWithPreferencesFromFile</span><span class="token punctuation">(</span><span class="token keyword">const</span> LppLocalPreferences<span class="token operator">*</span> <span class="token keyword">const</span> localPreferences<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> absoluteOrRelativePathWithoutTrailingSlash<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> absoluteOrRelativePathToProjectPreferences<span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>オプションのローカル環境設定を使用してデフォルトエージェントを作成し、指定されたパスからプロジェクト環境設定を読み込みます。</td>
                  </tr>

                  <tr>
                    <td width="70%" class="notranslate"><strong>
                      <code class=" language-cpp"><span class="token keyword">void</span> lpp<span class="token operator">::</span><span class="token function">LppDestroyDefaultAgent</span><span class="token punctuation">(</span>LppDefaultAgent<span class="token operator">*</span> agent<span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>指定されたデフォルトエージェントを破棄します。</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>同期エージェントを作成するAPI</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="70%" class="notranslate"><strong>
                      <code class=" language-cpp">lpp<span class="token operator">::</span>LppSynchronizedAgent lpp<span class="token operator">::</span><span class="token function">LppCreateSynchronizedAgent</span><span class="token punctuation">(</span><span class="token keyword">const</span> LppLocalPreferences<span class="token operator">*</span> <span class="token keyword">const</span> localPreferences<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> absoluteOrRelativePathWithoutTrailingSlash<span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>任意のローカル環境設定を使用して同期エージェントを作成します。</td>
                  </tr>

                  <tr>
                    <td width="70%" class="notranslate"><strong>
                      <code class=" language-cpp">lpp<span class="token operator">::</span>LppSynchronizedAgent lpp<span class="token operator">::</span><span class="token function">LppCreateSynchronizedAgentWithPreferences</span><span class="token punctuation">(</span><span class="token keyword">const</span> LppLocalPreferences<span class="token operator">*</span> <span class="token keyword">const</span> localPreferences<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> absoluteOrRelativePathWithoutTrailingSlash<span class="token punctuation">,</span> <span class="token keyword">const</span> LppProjectPreferences<span class="token operator">*</span> <span class="token keyword">const</span> projectPreferences<span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>指定されたプロジェクト環境設定とオプションのローカル環境設定を使って同期エージェントを作成します。</td>
                  </tr>

                  <tr>
                    <td width="70%" class="notranslate"><strong>
                      <code class=" language-cpp">lpp<span class="token operator">::</span>LppSynchronizedAgent lpp<span class="token operator">::</span><span class="token function">LppCreateSynchronizedAgentWithPreferencesFromFile</span><span class="token punctuation">(</span><span class="token keyword">const</span> LppLocalPreferences<span class="token operator">*</span> <span class="token keyword">const</span> localPreferences<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> absoluteOrRelativePathWithoutTrailingSlash<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> absoluteOrRelativePathToProjectPreferences<span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>任意のローカル環境設定を使用して同期エージェントを作成し、指定されたパスからプロジェクト環境設定を読み込みます。</td>
                  </tr>

                  <tr>
                    <td width="70%" class="notranslate"><strong>
                      <code class=" language-cpp"><span class="token keyword">void</span> lpp<span class="token operator">::</span><span class="token function">LppDestroySynchronizedAgent</span><span class="token punctuation">(</span>LppSynchronizedAgent<span class="token operator">*</span> agent<span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>指定された同期エージェントを破棄します。</td>
                  </tr>
                </tbody>
              </table>
            </div>


            <h3 id="creating_default_agent"><a href="#creating_default_agent">デフォルトエージェントの作成</a></h3>
            <p>ほとんどのアプリケーションやプロジェクトでは、最初にデフォルトエージェントを作成します：</p>
<pre class="notranslate"><code class=" language-cpp"><span class="token comment" spellcheck="true">// include the API for Windows, 64-bit, C++</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"LivePP/API/x64/LPP_API_x64_CPP.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// create a default agent, loading the Live++ agent from the given path, e.g. "ThirdParty/LivePP"</span>
  lpp<span class="token operator">::</span>LppDefaultAgent lppAgent <span class="token operator">=</span> lpp<span class="token operator">::</span><span class="token function">LppCreateDefaultAgent</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span> absoluteOrRelativePathWithoutTrailingSlash<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// bail out in case the agent is not valid</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lpp<span class="token operator">::</span><span class="token function">LppIsValidDefaultAgent</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lppAgent<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// enable Live++ for certain modules</span>
  <span class="token comment" spellcheck="true">// ...</span>

  <span class="token comment" spellcheck="true">// run the application</span>
  <span class="token comment" spellcheck="true">// ...</span>
  Application<span class="token operator">::</span><span class="token function">Exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// destroy the Live++ agent</span>
  lpp<span class="token operator">::</span><span class="token function">LppDestroyDefaultAgent</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lppAgent<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

            <p>内部的には、要求されたプラットフォームと言語用の正しい共有ライブラリをロードし、いくつかの整合性チェックを実行してから、利用可能なすべてのAPIで返されたオブジェクトを満たします。返される<code class="notranslate language-cpp code-in-text">LppDefaultAgent</code>オブジェクトは、関数ポインタを使用して共有ライブラリにAPIを格納する、プラットフォームに依存しない型です。</p>

            <p>上記のコード例では、デフォルトのエージェントがメイン ループ、エンジン フレームなどについて何も知る必要がないことに注意してください。このアプローチの利点は、ゲームやゲーム エンジンのような典型的な<strong>Update, Render, Present</strong>ループに従わないアプリケーションと美しく統合できるため、イベントベースのアプリケーションでも動作することです<a href="https://www.qt.io" target="_blank">Qt</a>を使って構築しました。</p>

            <div class="callout callout-info-MM" role="alert">
              <h4>注意</h4>
              <p>
                特定のプラットフォーム（WindowsやXboxなど）では、Agentは自動的に<a href="#bridge">Bridge</a>ヘルパープロセスを起動します。              </p>
            </div>

            <h3 id="creating_synchronized_agent"><a href="#creating_synchronized_agent">同期エージェントの作成</a></h3>
            <p>フレームベースのアプリケーションに特に有用な同期エージェントを使用すると、ホット再読み込みとホット再起動の要求を<strong>いつ</strong>、<strong>どのように</strong>処理するかを制御できます：</p>
<pre class="notranslate"><code class=" language-cpp"><span class="token comment" spellcheck="true">// include the API for Windows, 64-bit, C++</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"LivePP/API/x64/LPP_API_x64_CPP.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// create a synchronized agent, loading the Live++ agent from the given path, e.g. "ThirdParty/LivePP"</span>
  lpp<span class="token operator">::</span>LppSynchronizedAgent lppAgent <span class="token operator">=</span> lpp<span class="token operator">::</span><span class="token function">LppCreateSynchronizedAgent</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span> absoluteOrRelativePathWithoutTrailingSlash<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// bail out in case the agent is not valid</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lpp<span class="token operator">::</span><span class="token function">LppIsValidSynchronizedAgent</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lppAgent<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// enable Live++ for certain modules</span>
  <span class="token comment" spellcheck="true">// ...</span>

  <span class="token comment" spellcheck="true">// run the main loop</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>MainLoop<span class="token operator">::</span><span class="token function">NextFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// listen to hot-reload and hot-restart requests</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lppAgent<span class="token punctuation">.</span><span class="token function">WantsReload</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LPP_RELOAD_OPTION_SYNCHRONIZE_WITH_RELOAD<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// client code can do whatever it wants here, e.g. synchronize across several threads, the network, etc.</span>
      <span class="token comment" spellcheck="true">// ...</span>
      lppAgent<span class="token punctuation">.</span><span class="token function">Reload</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LPP_RELOAD_BEHAVIOUR_WAIT_UNTIL_CHANGES_ARE_APPLIED<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>lppAgent<span class="token punctuation">.</span><span class="token function">WantsRestart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// client code can do whatever it wants here, e.g. finish logging, abandon threads, etc.</span>
      <span class="token comment" spellcheck="true">// ...</span>
      lppAgent<span class="token punctuation">.</span><span class="token function">Restart</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LPP_RESTART_BEHAVIOUR_INSTANT_TERMINATION<span class="token punctuation">,</span> <span class="token number">0u</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    MainLoop<span class="token operator">::</span><span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    MainLoop<span class="token operator">::</span><span class="token function">Render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    MainLoop<span class="token operator">::</span><span class="token function">Present</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// destroy the Live++ agent</span>
  lpp<span class="token operator">::</span><span class="token function">LppDestroySynchronizedAgent</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lppAgent<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

            <p>デフォルトエージェントと同様に、返される<code class="notranslate language-cpp code-in-text">LppSynchronizedAgent</code>オブジェクトは、関数ポインタを使用して共有ライブラリにAPIを格納するプラットフォームに依存しない型です。</p>

            <p>
              同期エージェントは、コードパッチがフレーム中の特定の時点、例えばフレームの開始時または終了時にのみ発生することを保証するために使用できます。古いメモリレイアウトを使用して割り当てられたオブジェクトが、異なるメモリレイアウトを期待する新しいコードでアクセスされるのを防ぐためです。            </p>
            <p>
              さらに、同期エージェントを使用することで、フレーム途中で関数にパッチが適用されることがなくなり、古いコードを使用して更新されたオブジェクトと新しいコードを使用して更新されたオブジェクトなどの間で、わずかな動作のずれが生じることがなくなります。次の例はこれを示しています：<pre class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">UpdateNumber</span><span class="token punctuation">(</span><span class="token keyword">float</span> deltaTime<span class="token punctuation">,</span> size_t index<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  g_numbers<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1.0f</span><span class="token operator">*</span>deltaTime<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token keyword">float</span> deltaTime<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0u</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numberCount<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">UpdateNumber</span><span class="token punctuation">(</span>deltaTime<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
            </p>
            <p>
             <code class="notranslate code-in-text language-cpp"><span class="token keyword">void</span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token keyword">float</span> deltaTime<span class="token punctuation">)</span></code>のループが実行されている間に、<code class="notranslate code-in-text language-cpp"><span class="token keyword">void</span> <span class="token function">UpdateNumber</span><span class="token punctuation">(</span><span class="token keyword">float</span> deltaTime<span class="token punctuation">,</span> size_t index<span class="token punctuation">)</span></code>変更された場合を考えてみましょう。この場合、いくつかの数値は古いコードで更新され、残りの数値（変更後に処理された数値）は新しいコードで更新されることになる。これはおそらくほとんどの場合問題にはなりませんが、もし問題になる場合は、synchronized Agentを使用することで、すべてのコードパッチが適用されるまで処理が保持されるようにすることができます。            </p>

            <div class="callout callout-info-MM" role="alert">
              <h4>注意</h4>
              <p>同期エージェントを使用するかどうかにかかわらず、実行可能コードの実際のパッチは常にLive++によって安全な方法で行われます。これは、CPUが機械語コード・レベルで2つに引き裂かれた命令を見ることがないことを意味します。</p>
            </div>


            <h2 id="enabling_livepp"><a href="#enabling_livepp">Live++の有効化</a></h2>
            <p>エージェントを作成した後、Live++に、どのモジュールに対して有効にするかを指示する必要があります。これは、以下のエージェントAPIで行うことができます：</p>

            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>API</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="50%" class="notranslate"><strong>
                      <code class=" language-cpp"><span class="token keyword">void</span> Agent<span class="token operator">::</span><span class="token function">EnableModule</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> relativeOrFullPath<span class="token punctuation">,</span> LppModulesOption options<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> callbackContext<span class="token punctuation">,</span> LppFilterFunction<span class="token operator">*</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>与えられたモジュール（.exeまたは.dll）に対して、与えられたオプションでLive++を有効にし、オプションのコールバック関数とコンテキストを使用してモジュールをフィルタリングします。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate"><strong>
                      <code class=" language-cpp"><span class="token keyword">void</span> Agent<span class="token operator">::</span><span class="token function">EnableModules</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span> arrayOfRelativeOrFullPaths<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span> LppModulesOption options<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> callbackContext<span class="token punctuation">,</span> LppFilterFunction<span class="token operator">*</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>与えられたモジュール（.exe と .dll の任意の組み合わせ）に対して、与えられたオプションで Live++ を有効にし、オプションのコールバック関数とコンテキストを使用してモジュールをフィルタリングします。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate"><strong>
                      <code class=" language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">bool</span> <span class="token function">LppFilterFunction</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> context<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>フィルタ関数は、ユーザーが提供するコンテキスト引数とモジュールパスで呼び出されます。関数は、モジュールがロードされるべきであれば<code class="notranslate code-in-text language-cpp"><span class="token boolean">true</span></code>、そうでなければ<code class="notranslate code-in-text language-cpp"><span class="token boolean">false</span></code>返す必要があります。</td>
                  </tr>
                </tbody>
              </table>
            </div>


            <div class="callout callout-info-MM" role="alert">
              <h4>重要</h4>
              <p>
                DLL を使用する場合、DllMain エントリ・ポイントでこれらの API を<strong>決して</strong>呼び出さないことが重要です。<br/>Live++は、DLLがロードされている間、<a href="https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices" target="_blank">オペレーティング・システムによってサポートされていない</a>いくつかの操作を実行する必要があります。              </p>
            </div>

            <p>これらの API を呼び出す場合は、該当するモジュールがすでにプロセスにロードされていることを確認する必要があります。API自体はノンブロッキングでスレッドセーフであり、どのスレッドからでもいつでも呼び出すことができます。期待されるパスは、絶対パスでも、これらのAPIを呼び出すモジュールからの相対パスでもかまいません。</p>
            <p><code class="notranslate language-cpp code-in-text">LppModulesOption</code>列挙型には、以下のオプションがあります：</p>

            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>オプション</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="50%" class="notranslate"><strong>
                      <code class="language-cpp">LPP_MODULES_OPTION_NONE</code>
                    </strong></td>
                    <td>指定されたモジュールに対してのみ Live++ を有効にします。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate"><strong>
                      <code class="language-cpp">LPP_MODULES_OPTION_ALL_IMPORT_MODULES</code>
                    </strong></td>
                    <td>指定 さ れたモジ ュ ール と そのすべての<a href="https://learn.microsoft.com/en-us/cpp/build/linking-an-executable-to-a-dll?view=msvc-170#implicit-linking" target="_blank">イ ン ポー ト モジ ュ ールに</a>対 し て Live++ を有効に し ます。</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <p>フィルター関数のコールバックを使用する場合、フィルター関数が<code class="notranslate code-in-text language-cpp"><span class="token boolean">true</span></code>返したモジュールだけが Live++ で有効になります。</p>

            <p>さらに、その戻り値を、モジュールへのパスを期待するAPIに直接渡すことができるため、現在/呼び出し中のモジュールのLive++を有効にするための簡単なAPIがもう一つあります：</p>

            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>API</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="50%" class="notranslate"><strong>
                      <code class=" language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> lpp<span class="token operator">::</span><span class="token function">LppGetCurrentModulePathANSI</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>現在のモジュールの完全修飾パス、例えば<strong>"C:\Dir\App.exe "</strong>を返します。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate"><strong>
                      <code class=" language-cpp"><span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> lpp<span class="token operator">::</span><span class="token function">LppGetCurrentModulePath</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>現在のモジュールの完全修飾パス、例えば<strong>"C:\Dir\App.exe "</strong>を返します。</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <div class="callout callout-info-MM" role="alert">
              <h4>ヒント</h4>
              <p>
                厳密には必要なくても、アプリケーションのできるだけ早い段階で、理想的にはメ イン・エントリ・ポイントの開始時に Live++ を有効にすることを推奨します。これにより、Brokerはアプリケーションと同時にファイルのロードと解析を開始し、起動時のパフォーマンスを最大化できます。AAAサイズのプロジェクトであっても、ターゲット・アプリケーションへのパフォーマンスへの影響は最小限に抑えられます。              </p>
            </div>

            <p>
              Live++は、<code class="notranslate language-cpp code-in-text">Enable*</code>APIが呼び出された後にファイルの読み込みと解析を開始しますが、これらのAPIを呼び出すタイミングは完全に自由であることに注意してください。Live++がマシンに不要な待ち時間を発生させ（たとえば、非常に大きなPDBや非SSDドライブが原因）、アプリケーション起動のたびに待ち時間を発生させたくないと感じる場合は、必要なときだけLive++をロードしてもまったく問題ありません。<br/>この場合、キーボードショートカット、ゲーム内コンソール、デバッグメニューなどを使用して、Live++のロードと有効化のみを手動で行うことが有益となる場合があります。            </p>


            <h2 id="dynamically_loaded_modules"><a href="#dynamically_loaded_modules">動的にロードされるモジュール</a></h2>
            <p>実行時に動的にモジュールをロードおよびアンロードする場合、アンロードする前にLive++にモジュールを無効にする必要があることを伝える必要があります。これは、いくつかの Agent API を使用して行うことができます：</p>

            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>API</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="50%" class="notranslate"><strong>
                      <code class=" language-cpp"><span class="token keyword">void</span> Agent<span class="token operator">::</span><span class="token function">DisableModule</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> relativeOrFullPath<span class="token punctuation">,</span> LppModulesOption options<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> callbackContext<span class="token punctuation">,</span> LppFilterFunction<span class="token operator">*</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>与えられたモジュール（.exeまたは.dll）に対して、与えられたオプションでLive++を無効にし、オプションのコールバック関数とコンテキストを使用してモジュールをフィルタリングします。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate"><strong>
                      <code class=" language-cpp"><span class="token keyword">void</span> Agent<span class="token operator">::</span><span class="token function">DisableModules</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span> arrayOfRelativeOrFullPaths<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span> LppModulesOption options<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> callbackContext<span class="token punctuation">,</span> LppFilterFunction<span class="token operator">*</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>与えられたオプションで、与えられたモジュール（.exeと.dllの任意の組み合わせ）のLive++を無効にし、オプションのコールバック関数とコンテキストを使用してモジュールをフィルタリングします。</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <p>これらのAPIによって無効にされたモジュールは、APIが呼び出されたときに、まだプロセスにロードされていなければなりません。繰り返しますが、API自体はノンブロッキングでスレッドセーフであり、いつでもどのスレッドからでも呼び出すことができます。期待されるパスは、絶対パスでも、これらのAPIを呼び出すモジュールからの相対パスでもよい。</p>

            <p>上記のAPIを使用する場合、モジュールを有効にするときに使用したのと同じ<code class="notranslate language-cpp code-in-text">LppModulesOption options</code>必ず使用してください。</p>

            <p>さらに、Agentは、モジュールがロードされたとき、またはアンロードされたときに、それぞれLive++を自動的に有効化および無効化するAPIを提供します：</p>

            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>API</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="50%" class="notranslate"><strong>
                      <code class=" language-cpp"><span class="token keyword">void</span> Agent<span class="token operator">::</span><span class="token function">EnableAutomaticHandlingOfDynamicallyLoadedModules</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> callbackContext<span class="token punctuation">,</span> LppFilterFunction<span class="token operator">*</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>Live++ に、動的にロードされるモジュールを自動的に処理させます：ロード時にモジュールを有効にし、アンロード時にモジュールを無効にします。すべてのモジ ュ ールは、 オプシ ョ ンの コ ールバ ッ ク 関数 と コ ン テ キ ス ト を用いて フ ィ ル タ リ ン グ さ れます。</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <p>他のAPIと同様に、フィルター関数コールバックを使用すると、フィルター関数が<code class="notranslate code-in-text language-cpp"><span class="token boolean">true</span></code>返したモジュールだけがLive++で有効になります。フィルタ関数を使用すると、どのモジュールを自動的に有効にしたり無効にしたりするかを細かく制御できます。どちらの引数もオプションなので、<code class="notranslate code-in-text language-cpp"><span class="token keyword">nullptr</span></code>渡すとフィルタリングは実行されません。</p>

            <div class="callout callout-info-MM" role="alert">
              <h4>例</h4>
              <p>Live++には、これを示す<strong>"12_DynamicallyLoadedDLLs"</strong>サンプルが同梱されています。</p>
            </div>            
          </section>


          <header>
            <h1 id="tools"><a href="#tools">ツール</a></h1>
          </header>

          <section>
            <h2 id="tools_hot_reload"><a href="#tools_hot_reload">ホット・リロード</a></h2>
            <p>ソース・コード・ファイルを変更したら、保存して<kbd class="notranslate">ctrl + alt + F11</kbd> を押します。このショートカットは、Live++アプリケーションにフォーカスがあるかどうかに関係なく機能します。</p>
            <p>あるいは、ツールメニューから<strong>"すべての変更をホットリロード"</strong>を呼び出すこともできます：</p>
            <p>
              <img src="assets/img/tools_menu_jpn.png" alt="Live++ tools menu">
            </p>

            <p>さらに、エージェントは、任意の時点でホット・リロード操作をスケジュールするAPIも提供しています：</p>

            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>API</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="50%" class="notranslate"><strong>
                      <code class=" language-cpp"><span class="token keyword">void</span> Agent<span class="token operator">::</span><span class="token function">ScheduleReload</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>ホットリロード操作をスケジュールし、<code class="notranslate code-in-text language-cpp"><span class="token function">WantsReload</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code>ができるだけ早く true を返すようにします。</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <p>これは、独自のショートカットをリッスンしたり、カスタムデバッグメニューなどからLive++ホット再ロードを呼び出したりする場合に便利です。</p>
            <p>内部的には、この操作はバックグラウンド・コンパイル処理をトリガします。コンパイルが成功すると、新しいコードがアプリケーションにロードされ、既存のコードとリンクされます。当然、元の実行ファイルに含まれていない関数も正しくリンクされます。</p>

            <div class="callout callout-info-MM" role="alert">
              <h4>ヒント</h4>
              <p>コンパイラとリンカの出力は常に、Broker UI の<strong>[Log]</strong>タブと Visual Studio や Rider などの IDE の出力ウィンドウの両方に記録されます。これにより、出力ウィンドウの行をダブルクリックするか、<kbd class="notranslate">F8</kbd> を押すことで、エラーの場所に移動できます。また、Broker UI の [<strong>Log]</strong>タブでエラーの該当行をダブルクリックすると、その行が強調表示され、IDE がエラーの場所に移動します：</p>
              <p>
                <img src="assets/img/double_click_on_log.png" alt="Live++ Broker UI">
              </p>
            </div>

            <div class="callout callout-info-MM" role="alert">
              <h4>例</h4>
              <p>Live++には、これを示す<strong>"01_HotReload"</strong>というサンプルが同梱されています。</p>
            </div>


            <h3 id="unity_file_splitting"><a href="#unity_file_splitting">ユニティ分割</a></h3>
            <p>
              Live++ は、登録されたモジュールの一部である unity/jumbo/blob ファイルを自動的に検出して分割します。そのようなすべてのunityファイルに対して、Live++は、次の例に示すように、含まれるすべての.cppファイルを独自の.objファイルに分割し、再構築と再コンパイルに使用します：            </p>
            <p>
<pre class="notranslate"><code class=" language-cpp"><span class="token comment" spellcheck="true">// these are the contents of Unity.cpp:</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"FileA.cpp"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"FileB.cpp"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"FileC.cpp"</span></span></code></pre>
              この例では、Unity.cppは、<strong>Unity.obj.lpp_split.FileA.obj</strong>、<strong>Unity.obj.lpp_split.FileB.obj</strong>、および<strong>Unity.obj.lpp_split.FileC.objに</strong>分割されます。つまり、ソース・ファイルが変更され、再コンパイルがトリガーされると、Live++はメインのUnityファイルではなく、1つの小さなファイルを再コンパイルするだけでよいことになります。その結果、反復時間が大幅に短縮されます。<strong>Compilands</strong>ビューでは、シングルファイル、unity、および分割コンパイランドも区別されます：            </p>
            <p>
              <img src="assets/img/unity_compilands_jpn.png" alt="Live++ Unity compilands">
            </p>
            <p>
              Unityの分割は、<a href="#project_preferences_unity_splitting">統合/Jumbo/BLOB/Amalgamated ファイルの分割を有効にする</a>設定を利用することで、プロジェクトごとに制御できます。より細かく制御したい場合は、分割したいすべてのコンパイランドのコマンドラインオプションのプリプロセッサ定義として<strong>LPP_FORCE_UNITY_SPLITTING</strong>を設定することで、コンパイランド単位で unity 分割を有効にすることができます。            </p>

            <div class="callout callout-info-MM" role="alert">
              <h4>注意</h4>
              <p>Unity 分割は、unity ファイルによってインクルードされた .cpp ファイルのどれかが最初にタッチされた時だけ実行されなければなりません。これは、unityファイルに含まれるすべての翻訳ユニットの再コンパイルにつながりますが、多くの場合、この操作は、特に最近のマルチコアマシンでは、unityファイル全体を再コンパイルするのと同じくらい高速です。</p>
            </div>

            <div class="callout callout-info-MM" role="alert">
              <h4>例</h4>
              <p>Live++には、これを実演する<strong>"04_UnitySplitting"</strong>というサンプルが同梱されています。</p>
            </div>


            <h3 id="halted_processes"><a href="#halted_processes">停止したプロセス</a></h3>
            <p>
              通常、Live++は、ホット・リロード操作がスケジュールされるとすぐに、変更されたファイルを自動的に収集し、バックグラウンドでコンパイルを開始します。しかし、Live++が有効なプロセスがデバッガーに保持されている場合（ブレークポイントなど）、プロセスは何も進行しないため、Live++はそのプロセスと通信できません。            </p>

            <h4>Visual Studio および Rider デバッガー</h4>
            <p>
              Visual Studio または Rider でデバッグする場合、Live++ はプロセスを Live++ と通信を継続できるモードにするために必要なアクションの自動化を試みます。成功すると、Broker UI ログに<strong>"自動化されたデバッガーを PID が XXXXX のプロセスにアタッチ" と</strong>表示され、Live++ は変更をコンパイルしてコード パッチをインストールします。その後、プロセスは再びデバッガの同じ命令で保持されます。            </p>

            <h4>その他のデバッガ</h4>
            <p>
              自動化に失敗した場合、または WinDbg などの他のデバッガーを使用している場合、UI ログに<strong>"PID が XXXXX のターゲットプロセスを待っています。プロセスがデバッガーで保留中の場合は、「続行」(Visual Studio および Rider では F5) を押します。"</strong>ホット・リロード操作のスケジューリング時に表示されます。アプリケーションを再開すると、Live++がコンパイルし、行った変更をインストールします。コンパイルが終了するまで、プロセスは新しい命令を実行しません。Live++ によってパッチがインストールされると、プロセスは自動的に実行を続行します。            </p>
            <p>
              この場合の一連の流れを以下に示します：              <ol>
                <li>デバッガがブレークポイントに遭遇し、プロセスを停止します。</li>
                <li>通常どおりデバッグが開始されます。</li>
                <li>現在デバッグ/実行中のコードに1つまたは複数の変更を加え、Live++のホット・リロードを呼び出します。</li>
                <li>Live++は変更されたファイルをピックアップし、デバッガで処理を続行するのを待ちます。</li>
                <li>F5キーを押すなどしてプロセスを続行します。</li>
                <li>プロセスはまだ停止していますが、今度はLive++によって停止されます。</li>
                <li>Live++はあなたの変更をコンパイルし、コード・パッチをインストールし、プロセスを続行させます。</li>
                <li>プロセスは<a href="#limitation_functions_on_the_stack">中断したところから実行を続けます</a>。</li>
              </ol>
            </p>

            <div class="callout callout-info-MM" role="alert">
              <h4>注意</h4>
              <p>
                このシナリオでは、Live++はインストールした<a href="#API_hooks">フックを</a>呼び出しません。              </p>
            </div>


            <h3 id="natvis_visualizations"><a href="#natvis_visualizations">Natvisビジュアライゼーション</a></h3>
            <p>
              Natvis 可視化は、Visual Studio デバッガによって理解される<a href="https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects" target="_blank">カスタム タイプの可視化ルール</a>です。            </p>
            <p>
              通常、<strong>.natvis</strong>ファイルは Live++ で作成されたパッチに対してデバッガーによって自動的にピックアップされます。しかし、そうでない場合は、これらのファイルを<a href="https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects#BKMK_natvis_location" target="_blank">ユーザー固有またはシステム全体のNatvisディレクトリに</a>置くことが役立ちます。
            </p>
          </section>


          <section>
            <h2 id="tools_hot_restart"><a href="#tools_hot_restart">ホット・リスタート</a></h2>
            <p>アプリケーションを終了して再起動するときに発生するビルド時間とリンク時間に対処するため、Live++は、ロードされたデータと内部キャッシュを持続させたままアプリケーションを再起動するメカニズムを提供しています。</p>
            <p>アプリケーションがメイン・ループに入ると、メイン・ループに入る前に呼び出されるスタートアップ関数などに加えられた変更の効果を確認するために、アプリケーションを再起動する必要があります。この場合、通常は次のような一連のイベントが発生します：</p>
            <ol>
              <li>
                ユーザーがアプリケーションを閉じる。              </li>
              <li>
                ビルド・システムが実行ファイルをリンクする。              </li>
              <li>
                ユーザーがアプリケーションを再度起動する。              </li>
              <li>
                Live++でモジュールが有効になる。これにより、PDBからデバッグ・データがロードされ、内部キャッシュが構築されます。              </li>
            </ol>

            <p>ステップ2.と4.は、特にAAAプロジェクトではかなりの時間がかかることがあります。Live++が提供するホット・リスタート機能を利用することで、この状況をかなり改善することができます：</p>
            <ol>
              <li>
                Live++は、興味のあるすべてのプロセスに再起動の準備を指示します。              </li>
              <li>
                プロセスは、何らかのクリーンアップを実行したい場合に備えて、オプションのコードを実行します。              </li>
              <li>
                Live++は、PDBからロードされたすべてのデータと内部キャッシュを維持したまま、関係するすべてのプロセスを再起動します。              </li>
              <li>
                Live++ではモジュールが有効になっている。これにより、既存のデバッグ・データとキャッシュが再利用され、以前にコンパイルされたパッチがインストールされる。              </li>
            </ol>
            <p>ホット再起動メカニズムを使用すると、リンク時間とLive++のロード時間がほとんど完全になくなることに注意してください。</p>

            <div class="callout callout-info-MM" role="alert">
              <h4>例</h4>
              <p>Live++には、これを実証する<strong>"08_HotRestart"</strong>というサンプルが同梱されています。</p>
            </div>


            <h3 id="hot_restart_request"><a href="#hot_restart_request">ホット・リスタートの要求</a></h3>
            <p>ホットリスタートのリクエストには4つのオプションがあります：</p>
            <ul>
              <li>
                <p>デフォルトのショートカット<kbd class="notranslate">ctrl + alt + R</kbd> を押します。このショートカットは、Live++アプリケーションにフォーカスがあるかどうかに関係なく機能します。</p>
              </li>
              <li>
                <p>ツール・メニューから<strong>"プロセスをホットリスタート"</strong>を実行する：</p>
                <p>
                  <img src="assets/img/tools_menu_jpn.png" alt="Live++ tools menu">
                </p>
                <p>これにより、現在Brokerに登録されているすべてのプロセスにホット再起動要求が送信されます。</p>
              </li>
              <li>
                <p>Brokerの<strong>処理</strong>ビューで1つまたは複数のプロセスを選択し、右クリックしてコンテキスト・メニューを開き、<strong>"選択したプロセスをホットリスタート"</strong>を選択します：</p>
                <p>
                  <img src="assets/img/processes_context_menu_jpn.png" alt="Processes view context menu">
                </p>
                <p>これにより、個々のプロセスをホットスタートさせることができ、クライアント/サーバシナリオで役立ちます。</p>
              </li>
              <li>
                <p>さらに、エージェントは、任意の時点でホットリスタート処理をスケジュールするための API も提供します：</p>

                <div class="table-responsive">
                  <table class="table table-bordered table-striped">
                    <thead>
                      <tr>
                        <th>API</th>
                        <th>説明</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td width="50%" class="notranslate"><strong>
                          <code class=" language-cpp"><span class="token keyword">void</span> Agent<span class="token operator">::</span><span class="token function">ScheduleRestart</span><span class="token punctuation">(</span>LppRestartOption option<span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                        </strong></td>
                        <td>ホット再起動操作をスケジュールし、<code class="notranslate code-in-text language-cpp"><span class="token function">WantsRestart</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code>ができるだけ早く true を返すようにします。</td>
                      </tr>
                    </tbody>
                  </table>
                </div>

                <p>これは、独自のショートカットをリッスンしたい場合や、カスタムデバッグメニューなどから Live++ ホット再起動を呼び出したい場合に便利です。</p>
              </li>
            </ul>


            <h3 id="hot_restart_default_agents"><a href="#hot_restart_default_agents">デフォルト・エージェント</a></h3>
            <p><a href="#creating_default_agent">デフォルト・エージェントを</a>使用する場合、内部実装がホット・リスタート要求に自動的に応答します。</p>


            <h3 id="hot_restart_synchronized_agents"><a href="#hot_restart_synchronized_agents">同期エージェント</a></h3>
            <p><a href="#creating_synchronized_agent">同期エージェントを</a>使用する場合、以下のAPIを使用してホット再起動要求に応答する必要があります：</p>

            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>API</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="70%" class="notranslate"><strong>
                      <code class=" language-cpp"><span class="token keyword">bool</span> Agent<span class="token operator">::</span><span class="token function">WantsRestart</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>Live++ がプロセスのホット・リスタートを望んでいるかどうかを返します。</td>
                  </tr>
                  <tr>
                    <td width="70%" class="notranslate"><strong>
                      <code class=" language-cpp"><span class="token keyword">void</span> Agent<span class="token operator">::</span><span class="token function">Restart</span><span class="token punctuation">(</span>LppRestartBehaviour behaviour<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> exitCode<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> commandLineArguments<span class="token punctuation">)</span><span class="token punctuation">;</span></code>
                    </strong></td>
                    <td>指定 さ れた動作を尊重 し てプ ロ セ ス を再起動 し ます。返されません。</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <h3>再起動の準備</h3>
            <p>
              ホット リスタートが要求された後、Live++ は、再起動の準備をする必要があることを関係するすべてのプロセスに通知します。再起動が要求されると、アプリケーションは定期的に（たとえばフレームごとに）<code class="notranslate code-in-text language-cpp"><span class="token keyword">bool</span> <span class="token function">WantsRestart</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code>を呼び出してtrueを返す必要があります。再起動を開始する前に、任意のクリーンアップ（ファイルのフラッシュなど）を実行できます。            </p>
            <h3>再スタートの開始</h3>
            <p>
              アプリケーションが任意のクリーンアップタスクを実行し終わったら、すぐに<code class="notranslate code-in-text language-cpp"><span class="token keyword">void</span> <span class="token function">Restart</span><span class="token punctuation">(</span>LppRestartBehaviour behaviour<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> exitCode<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword"> wchar_t*</span> <span class="token keyword">const</span> commandLineArguments<span class="token punctuation">)</span></code>呼び出す必要があります。これは Live++ にプロセスの再起動を知らせ、プロセスを終了します。<code class="notranslate code-in-text language-cpp"><span class="token keyword">const</span> <span class="token keyword"> wchar_t*</span> <span class="token keyword">const</span> commandLineArguments</code>パラメータはオプションで、再起動されたプロセスに渡されます。<code class="notranslate code-in-text language-cpp"><span class="token keyword">nullptr</span></code>使用すると、元のコマンドライン環境でプロセスを再起動します。            </p>
            <p>
              再起動されたプロセスのいずれかにアタッチされている Visual Studio または Rider デバッガは、ホット再起動操作が完了した後、Live++ によって対応するプロセスに自動的に再アタッチされます。            </p>
            <p>
              終了時の動作は、次の表に示すように、<code class="notranslate language-cpp code-in-text">LppRestartBehaviour</code>引数によって異なります：            </p>

            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>再起動時の動作</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="50%" class="notranslate">LPP_RESTART_BEHAVIOUR_DEFAULT_EXIT</td>
                    <td>指定された終了コードで<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess" target="_blank">ExitProcess()</a>呼び出します。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate">LPP_RESTART_BEHAVIOUR_EXIT_WITH_FLUSH</td>
                    <td>指定された終了コードで<a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/exit-exit-exit" target="_blank">exit()</a>呼び出します。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate">LPP_RESTART_BEHAVIOUR_EXIT_WITHOUT_FLUSH</td>
                    <td>指定された終了コードで<a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/exit-exit-exit" target="_blank">_Exit()</a>呼び出します。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate">LPP_RESTART_BEHAVIOUR_INSTANT_TERMINATION</td>
                    <td>指定された終了コードで<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess" target="_blank">TerminateProcess()</a>呼び出します。</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <div class="callout callout-info-MM" role="alert">
              <h4>ヒント</h4>
              <p>再起動を要求した後、アプリケーションはオプションのクリーンアップタスクを実行し、<code class="notranslate code-in-text language-cpp"><span class="token keyword">void</span> <span class="token function">Restart</span><span class="token punctuation">(</span>LppRestartBehaviour behaviour<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> exitCode<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword"> wchar_t*</span> <span class="token keyword">const</span> commandLineArguments<span class="token punctuation">)</span></code>呼び出すために10秒まで許可されています。この時間を超えると、Live++はこのプロセスの再起動を放棄します。</p>
            </div>
          </section>


          <section>
            <h2 id="tools_hot_fix"><a href="#tools_hot_fix">ホットフィックス</a></h2>
            <p>
              Live++は、裏で<a href="https://docs.microsoft.com/en-us/windows/desktop/debug/structured-exception-handling" target="_blank">構造化例外処理（SEH）</a>使用するカスタムの<a href="https://docs.microsoft.com/en-us/windows/desktop/debug/vectored-exception-handling" target="_blank">ベクトル化例外ハンドラ（VEH）</a>を介して、すぐに使用できる強力なエラー回復を提供します。Live++のホット・リロード機能と組み合わせることで、アクセス違反やゼロによる除算など、致命的なエラーからの回復が可能になります。Live++の例外ハンドラを使用すると、プロセスが未処理の例外（アクセス違反など）を発生させるたびに、このハンドラが呼び出されます。            </p>
            <p>
              Visual Studio や Rider などのデバッガがプロセスにアタッチされている場合、デバッガは常に例外を処理する最初のチャンスを得ます。            </p>
            <p>
              <img src="assets/img/exception_handler_vs.png" alt="Visual Studio exception handler">
            </p>
            <p>
              デバッガでプロセスを続行すると、Live++の例外ハンドラが起動され、Brokerのダイアログが開いて、この例外の処理方法を決定することができます：            </p>
            <p>
              <img src="assets/img/exception_handler_broker_jpn.png" alt="Live++ 例外ハンドラー">
            </p>
            <p>
              表示されたコール・スタックの行をダブルクリックすると、Visual Studio または Rider でその場所に対応するソース・ファイルが開きます。            </p>            
            <p>
              例外ハンドラが提供するオプションは以下のとおりです：              <ul>
                <li>
                 <strong>"命令を無効にする":</strong><br/>フォールトを起こしたマシン命令を完全に無効にします。これは、再コンパイルが可能な独自のモジュール/ソースファイルから例外が発生した場合に便利なオプションですが、Visual Studio Runtime のようなサードパーティのコードなどには決して使用しないでください。                </li>
                <li>
                 <strong>"命令を無視":</strong><br/>フォールトを発生させたマシン命令を一度だけ無視します。次に対応する関数が呼び出されたとき、その間にコードが再コンパイルされない限り、その命令は同じ例外を引き起こします。                </li>
                <li>
                 <strong>"終了関数":</strong><br/>現在の関数を離れ、親関数で実行を継続する。さらに、完全なSEH情報が利用可能な場合、スタックは巻き戻され、ローカル変数はデストラクタが呼び出されます。                </li>
                <li>
                 <strong>"実行を続行":</strong><br/>この例外を一旦無視して実行を続ける。この例外は、もしあれば、次にインストールされる例外ハンドラに渡される。最後にインストールされた例外ハンドラが例外を処理する機会を得た後、プロセスは（デバッガがアタッチされていれば）デバッガ内で停止するか、終了します。                </li>
              </ul>
            </p>

            <p>
              例外ハンドラ・ダイアログが表示されている間は、通常どおりLive++を使用してコードを変更したり再コンパイルしたりすることができます。ただし、新しいコードはバックグラウンドでインストールされますが、プロセスの実行は<a href="#limitation_functions_on_the_stack">障害発生時点から継続される</a>ため、問題の例外をどのように処理するか決定する必要があることに注意してください。            </p>

            <div class="callout callout-info-MM" role="alert">
              <h4>注意</h4>
              <p>
                このシナリオでは、Live++はコードの再コンパイル時に<a href="#API_hooks">フックを</a>呼び出しません。              </p>
            </div>

            <div class="callout callout-info-MM" role="alert">
              <h4>ヒント</h4>
              <p>
                実行ファイルでSEH情報を利用できるようにするには、次のコンパイラ設定を有効にする必要があります：              </p>
              <p><span class="notranslate label label-default label-custom-MM">C/C++ -&gt; Code Generation -&gt; Enable C++ Exceptions -&gt; Yes with SEH Exceptions (/EHa) です。</span></p>
              <p>
                SEH情報は、現在の関数を離れるときにスタックを巻き戻すためにのみ必要です。例外ハンドラがSEH例外情報を持っていない場合でも、問題なく動作しますが、スタック巻き戻しは実行されません。              </p>
            </div>

            <div class="callout callout-info-MM" role="alert">
              <h4>例</h4>
              <p>Live++には、これを示す<strong>"03_HotFixCrashRecovery"</strong>というサンプルが同梱されています。</p>
            </div>
          </section>


          <section>
            <h2 id="tools_hot_deoptimize"><a href="#tools_hot_deoptimize">ホット・デオプティマイズ</a></h2>
            <p>
              コードをその場で最適化解除することで、アプリケーションのデバッグ性と反復時間のバランスをとることができます。最適化されていないデバッグビルドは、最適化されたリテールビルドよりもはるかにデバッグしやすいのですが、開発中に使用するには遅すぎることがよくあります。一方、最適化されたビルドははるかに優れたパフォーマンスを提供しますが、デバッグが非常に困難です。
            </p>
            <p>
              これを緩和するために、Live++ は、実行中のアプリケーションで、コードの最適化解除、コードのデバッグ、完全に最適化されたビルドへの復帰を簡単に行える機能を提供します。Hot-Deoptimize 機能を使用する場合、翻訳単位は必要に応じて最適化解除されるため、初期費用は発生しません。これは他のアプローチとは異なり、さらに Hot-Deoptimize は IDE に完全に依存せず、サポートされているすべてのプラットフォームで使用できます。
            </p>
            <p>
              これは、最適化フラグが無効になる以外は、元のコンパイラー・オプションを使用してファイルを再コンパイルする。これは、マクロを定義するために使用されるプリプロセッサ定義やその他のフラグが、最適化解除バージョンでも設定されることを意味します。アサーションなどの機能は、デバッグビルドでのみ定義されるマクロを使用することが多いからです。
            </p>
            <p>
              Live++が提供するオプションは以下の通りです：              
              <ul>
                <li>
                  Brokerの<strong>コンパイル単位</strong>ビューで1つまたは複数のファイルを選択し、右クリックしてコンテキスト・メニューを開き、<strong>選択したコンパイル単位の最適化を切り替える</strong>選択すると、選択したコンパイランドが即座に最適化解除されます。                
                </li>
                <li>また、<strong>選択したコンパイル単位を最適化戻しのために待ち行列に入れる</strong>選択することで、後で最適化を解除するためにコンパイランドをキューに入れることもできます。キューに入れたコンパイランドの最適化は、<strong>待ち行列の最適化戻し</strong>アクションを選択することで開始できます。                  <p>
                    <img src="assets/img/compilands_context_menu_jpn.png" alt="Compiland view context menu">
                  </p>
                </li>
                <li>
                  Visual Studio または Rider のデフォルトのショートカット<kbd class="notranslate">ctrl + alt + O</kbd> を押すことで、現在開いているファイルの最適化状態を切り替えることができます。                </li>
                <li>
                  また、ファイルの先頭にマクロ<strong>LPP_DISABLE_OPTIMIZATIONS</strong>を置き、変更をホット・リロードすることでも、ファイルの最適化状態を切り替えることができます。この方法の欠点は、Live++ API<strong>"LivePP/API/x64/LPP_API_x64_CPP.h "</strong>をこのファイルで表示する必要があり、最適化解除の状態を<strong>コンパイル単位</strong>ビューで追跡できないことです。                </li>
                <li>
                  キューに入れられたコンパイランドは、コンテキスト・メニューの<strong>選択したコンパイル単位を最適化戻しのために待ち行列に入れる</strong>選択することで、再びキューに入れることができます。                </li>
                <li>
                  すべてのコンパイランドを元の最適化状態に戻したい場合は、<strong>すべてを最適化戻し</strong>アクションを選択します。                </li>
              </ul>
            </p>
            <p>
              現在最適化解除状態にあるソースファイルは<strong>コンパイル単位</strong>ビューで<img src="assets/img/deoptimized_compiland.svg" alt="Deoptimized compiland symbol" width="20" height="20"> の記号で、現在キュー状態にあるソースファイルは<img src="assets/img/queued_compiland.svg" alt="Queued compiland symbol" width="20" height="20"> の記号で、それぞれ示されます：            </p>
            <p>
              <img src="assets/img/compilands_deoptimized_jpn.png" alt="Compiland view deoptimized compilands">
            </p>

            <div class="callout callout-info-MM" role="alert">
              <h4>例</h4>
              <p>Live++には、これを示す<strong>"05_ToggleOptimizations"</strong>というサンプルが同梱されています。</p>
            </div>
          </section>


          <section>
            <h2 id="multi_process_editing"><a href="#multi_process_editing">マルチプロセス編集</a></h2>
            <p>ある種のクライアント/サーバーやエディター/ゲームのセットアップでは、変更を複数のプロセスや同じアプリケーションの複数のインスタンスに一度にホット・ロードできると、非常に便利です。Live++では、これはすぐに機能し、特別なセットアップを必要としません。</p>
            <p>Brokerの<strong>処理</strong>ビューには、現在Live++に登録されているすべてのプロセスが表示されます：</p>
            <p>
              <img src="assets/img/processes_jpn.png" alt="Processes view">
            </p>
            <p>
              Live++がサポートするすべての操作は、登録されている数に関係なく、影響を受けるプロセスまたは選択されたプロセスに対して実行されます。Live++は、複数のモジュールまたはアプリケーションの一部であるソース・ファイルの変更が、影響を受けるすべてのプロセスにコンパイルされ、ホット・ロードされることを自動的に確認します。            </p>
            <p>
              さらに、Live++は、実行可能ファイルがリンクされなかったり、ディスク上で変更されなかったりしても、すべてのコード変更をLive++アプリケーションの後続インスタンスにロード中に自動的に注入し、新しい動作をもたらします。その後、コードが変更されると、実行中のすべてのプロセスにホット・ロードされます。            </p>

            <div class="callout callout-info-MM" role="alert">
              <h4>例</h4>
              <p>Live++には、これを示す<strong>"07_MultipleProcesses"</strong>というサンプルが同梱されています。</p>
            </div>
          </section>


          <section>
            <h2 id="networked_editing"><a href="#networked_editing">ネットワーク編集</a></h2>
            <p><a href="#multi_process_editing">マルチプロセス編集と</a>同様に、Live++を任意のマシン上で実行されているリモートプロセスで動作させるために、特別なコード設定は必要ありません。唯一の要件は、それらのリモート・プロセスがLAN接続を介してローカルBrokerに接続することであり、これは次のように設定する必要があります：</p>
            <ul>
              <li>
                <p>ローカル・マシンでBrokerを起動し、ウィンドウ・タイトルに表示されているホスト名またはIPアドレス（例：192.168.8.147）をメモする：</p>
                <p>
                  <img src="assets/img/broker_window_title.png" alt="Live++ Broker window title">
                </p>
              </li>
              <li>
                <p>リモートマシンでBrokerを起動し、<span class="notranslate label label-default label-custom-MM">編集 -> グローバル設定... -> ネットワーク</span>に進み、Brokerを実行するローカルマシンのホスト名またはIPアドレスを入力し、<strong>保存</strong>を押します：</p>
                <p>
                  <img src="assets/img/global_preferences_network_jpn.png" alt="Global preferences network">
                </p>
                <p>これにより、リモートマシンのグローバル環境設定が保存されます。</p>
              </li>
            </ul>

            <p>
              ネットワーク編集を機能させるには、まずローカルマシンのアプリケーションを起動し、次にリモートマシンのアプリケーションを起動する必要があります。ただし、Live++はローカルとリモートのプロセスが混在していても、また同じアプリケーションの複数のインスタンスがどのマシンにあっても動作します。            </p>

            <div class="callout callout-info-MM" role="alert">
              <h4>注意</h4>
              <p>Live++が必要とする情報のほとんどは、ローカル・マシン上でのみ利用可能であるため、コードの変更はローカル・マシン上でのみピックアップされ、コンパイルされます。</p>
            </div>            

            <p>
              接続されたマシンとプロセスは、それぞれ<strong>ターゲット</strong>ビューと<strong>処理</strong>ビューで確認できます：              
            </p>
            <p>
              <img src="assets/img/targets_jpn.png" alt="Broker targets view">
            </p>
            <p>
              <img src="assets/img/processes_jpn.png" alt="Broker processes view">
            </p>

            <div class="callout callout-info-MM" role="alert">
              <h4>例</h4>
              <p>Live++には、これを示す<strong>"10_NetworkedEditing"</strong>というサンプルが同梱されています。</p>
            </div>
          </section>


          <header>
            <h1 id="licensing"><a href="#licensing">ライセンス</a></h1>
          </header>

          <section>
            <h2 id="licensing_activation"><a href="#licensing_activation">アクティベーション</a></h2>
            <p>
              Live++を使用する前に、まずマシン上でライセンスをアクティベートする必要があります。これを行うには、Brokerを起動し、メインメニューから<span class="notranslate label label-default label-custom-MM">ライセンス許諾 -> アクティベート...</span>選択し、ライセンスをアクティベートするプラットフォームと言語を選択します（例：<strong>Windows、C++）。</strong>アクティベーションコードとユーザーIDを入力するダイアログが開きます：            </p>
            <p>
              <img src="assets/img/activate_license_jpn.png" alt="Broker license activation">
            </p>
            <p>アクティベーションコードは、Live++の購入時に配布されたもので、XXXX-XXXX-XXXXという形式の12文字のキーです。</p>
            <p>
              ユーザーIDは自由に選択することができ、指定されたアクティベーションコードに関連付けられたライセンスプール内であなたのライセンスを識別します。これは、オフラインでライセンスを無効化する必要がある場合に必要となります。例えば、既存のライセンスを無効化せずにマシンを再インストールした場合などです。一般的なユーザーIDの例は、<strong>"Jane home office "</strong>または<strong>"John laptop "</strong>です。          </p>
            <p>ダイアログで<strong>「OK</strong>」を押すと、Live++は入力されたデータを使ってアクティベーション・サーバーにコンタクトしようとします。指定されたアクティベーションコードが有効な場合、Live++はあなたのマシンに関連付けられ、あなただけが使用できるライセンスを生成します。それ以外の場合は、代わりにエラーが表示されます。</p>

            <div class="callout callout-info-MM" role="alert">
              <h4>注意</h4>
              <p>会社のファイアウォールやプロキシサーバーが原因でアクティベーションサーバーへの接続に問題が発生した場合は、サポートにお問い合わせください。</p>
            </div>

            <h2 id="licensing_deactivation"><a href="#licensing_deactivation">アクティベーションの解除</a></h2>
            <p>
              マシンの再インストールが必要な場合や、同僚が使用できるようにライセンスを失効させたい場合など、ライセンスの失効が必要な場合は、Brokerのメインメニューから<span class="notranslate label label-default label-custom-MM">ライセンス許諾 -> 非アクティブ化...</span>進み、<strong>WindowsやC++など</strong>、ライセンスを失効させたいプラットフォームと言語を選択します。これにより、アクティベーション・サーバー上のライセンスが無効化されます。            </p>


            <h2 id="licensing_trial"><a href="#licensing_trial">無料トライアル</a></h2>
            <p>
              まだライセンスを持っておらず、30日間の無料トライアルを試したい場合は、Live++ホット・リロードを起動すると、次のダイアログがポップアップします：            </p>
            <p>
              <img src="assets/img/licensing_jpn.png" alt="ライセンス許諾">
            </p>
            <p>
              このダイアログで<span class="notranslate label label-default label-custom-MM">トライアル版を使用</span>選択すると、Live++がアクティベーション・サーバーからトライアル・ライセンスを取得します。            </p>


            <h2 id="licensing_command_line_tools"><a href="#licensing_command_line_tools">コマンドライン ツール</a></h2>
            <p>
              Live++ インストールの<strong>CLI</strong>ディレクトリにあるコマンド ライン ツールを使用して、ライセンスのアクティベーションとアクティベーション解除を自動化することもできます。例えば、<strong>"LPP_License_x64_CPP.exe"</strong>は<strong>Windows、C++ の</strong>ライセンス管理を行います。            </p>
            <p>各ツールは、それぞれ<strong>"--activate "</strong>と"<strong>--deactivate "</strong>オプションでライセンスの有効化と無効化を行うことができます。詳細については、統合された<strong>"-h"</strong>ヘルプオプションを参照してください。</p>
            <p>
              <img src="assets/img/command_line_tools.png" alt="Command-line tools">
            </p>
          </section>


          <header>
            <h1 id="gui"><a href="#gui">GUI</a></h1>
            <p class="lead">Live++のBroker GUIは、登録されたターゲット、プロセス、モジュール、およびコンパイラランドの概要を提供する、ドッキングおよびフローティング可能な複数のウィンドウとビューで構成されています。</p>
          </header>

          <section>
            <h2 id="gui_views_targets"><a href="#gui_views_targets">ターゲット</a></h2>
            <p>
             <strong>ターゲット</strong>ビューには、接続されているローカルおよびリモートのすべてのマシン、そのプラットフォーム、IPアドレス、および登録されているプロセス数が表示されます。            </p>
            <p>
              <img src="assets/img/targets_jpn.png" alt="Targets view">
            </p>


            <h2 id="gui_views_processes"><a href="#gui_views_processes">処理</a></h2>
            <p>
             <strong>処理</strong>ビューには、登録されているすべてのプロセス、そのターゲット、プロセスID、実行ファイルへのフルパス、プロセスが起動したコマンドラインが表示されます。            </p>
            <p>
              <img src="assets/img/processes_jpn.png" alt="Processes view">
            </p>
            <p>
              さらに、<strong>処理</strong>ビューでは、右クリック時に以下のオプションを含むコンテキストメニューが表示されます：            </p>
            <p>
              <img src="assets/img/processes_context_menu_jpn.png" alt="Processes view context menu">
            </p>
            <ul>
              <li>
               <strong>"選択したローカルプロセスのログファイルを表示":</strong><br/>選択したプロセスに関連するログファイルを Windows エクスプローラーに表示します。              </li>
              <li>
               <strong>"選択したローカルプロセスのログファイルを開く":</strong><br/>対応するデフォルトのアプリケーションを使用して、選択したプロセスに関連するログファイルを開きます。              </li>
              <li>
               <strong>"選択したプロセスをホットリスタート":</strong><br/>選択したプロセスにホット再起動要求を送信します。              </li>
            </ul>


            <h2 id="gui_views_modules"><a href="#gui_views_modules">モジュール</a></h2>
            <p>
             <strong>モジュール</strong>ビューには、ロードされたすべてのモジュール、ロードされたプロセスのID、サイズ、ロードされたアドレス範囲が表示されます。            </p>
            <p>
              <img src="assets/img/modules_jpn.png" alt="Targets view">
            </p>


            <h2 id="gui_views_compilands"><a href="#gui_views_compilands">コンパイル単位</a></h2>
            <p>
             <strong>コンパイル単位</strong>ビューには、すべてのモジュールとそのコンパイランドが、それぞれのコンパイランドのソースパスとともに階層ツリーで表示されます。            </p>
            <p>
              <img src="assets/img/compilands_open_jpn.png" alt="Targets view">
            </p>
            <p>
              ツリービューでコンパイランドをダブルクリックすると、Visual Studio または Rider の実行中のインスタンスで対応するソースファイルが開きます。            </p>
            <p>
              さらに、<strong>コンパイル単位</strong>、右クリック時に以下のオプションを持つコンテキスト・メニューも提供されます：            </p>
            <p>
              <img src="assets/img/compilands_context_menu_jpn.png" alt="Compilands view context menu">
            </p>
            <ul>
              <li>
               <strong>"詳細を表示...":</strong><br/>コンパランドの詳細を別のダイアログで表示します。              </li>
              <li>
               <strong>"外部アプリケーションでコンパイル単位を開く...":</strong><br/>対応するデフォルトのアプリケーションを使用して、選択したコンパイランドのソースファイルを開きます。              </li>
              <li>
               <strong>"選択したコンパイル単位の最適化を切り替える":</strong><br/>選択したコンパランドの最適化状態を切り替えます。              </li>
              <li>
               <strong>"選択したコンパイル単位を最適化戻しのために待ち行列に入れる":</strong><br/>選択したコンパイランドを後で最適化解除するためにキューに入れます。              </li>
            </ul>
            <p>
             <strong>コンパイル単位の詳細</strong>ダイアログでは、PDB パス、コンパイラーパス、再コンパイルに使用したコマンドラインなど、各コンパイルランドの詳細情報が表示されます。            </p>
            <p>
              <img src="assets/img/compiland_details_jpn.png" alt="Compiland details dialog">
            </p>
          </section>


          <header>
            <h1 id="global_preferences"><a href="#global_preferences">グローバル環境設定</a></h1>
            <p class="lead">グローバル環境設定は、Broker のメインメニューから<span class="notranslate label label-default label-custom-MM">編集 -> グローバル設定...</span>を選択することで設定できます。Brokerの外観や動作をカスタマイズするためのいくつかのグローバルな設定を提供し、常にBrokerディレクトリの<strong>global_preferences.jsonに</strong>保存されます。</p>
            <p class="lead">
              オプションの<strong>global_preferences_default.json</strong>ファイルを提供することでデフォルト設定を定義し、同じディレクトリにオプションの<strong>global_preferences_override.json</strong>ファイルを提供することで設定を上書きすることができます。Live++は、以下の順序でファイルを読み込みます：            </p>
            <ul class="lead">
              <li>global_preferences_default.json</li>
              <li>global_preferences.json</li>
              <li>global_preferences_override.json</li>
            </ul>
            <p class="lead">
              この動作は、意味のあるデフォルト値を設定したり、チーム全体に対して特定のプリファレンスの値を強制したりしたい場合に便利です。            </p>
          </header>

          <section>
            <h2 id="global_preferences_ui"><a href="#global_preferences_ui">UI</a></h2>
            <p>
              <img src="assets/img/global_preferences_ui_jpn.png" alt="Global preferences UI">
            </p>
            <ul>
              <li>
                <strong>"言語:"</strong><br/>
                言語を選択します。
              </li>
              <li>
               <strong>"初期ウィンドウの状態:"</strong><br/>Broker を通常のサイズで起動するか、最大化するか、システムトレイに表示するかを選択できます。              </li>
              <li>
               <strong>"スタイル:"</strong><br/>明るいスタイルと暗いスタイルを選択できます。              </li>
              <li>
               <strong>"バージョン不一致のエラーを表示:"</strong><br/>これを有効にすると、Agent と Broker の API バージョンが一致しない場合、Broker はモーダルダイアログでエラーを表示します。              </li>
              <li>
               <strong>"通知領域にアニメーションアイコンを表示:"</strong><br/>これを有効にすると、操作の進行中に通知領域のアイコンがアニメーション表示されます。              </li>
              <li>
               <strong>"通知領域に色付きアイコンを表示:"</strong><br/>これを有効にすると、最後の操作が成功したかエラーになったかによって、通知領域のアイコンが色分けされます。              </li>
              <li>
               <strong>"タスクバーに進捗を表示:"</strong><br/>これを有効にすると、操作の進行中にタスクバーがアニメーション表示されます。              </li>
            </ul>

            <h2 id="global_preferences_logging"><a href="#global_preferences_logging">ロギング</a></h2>
            <p>
              <img src="assets/img/global_preferences_logging_jpn.png" alt="Global preferences logging">
            </p>
                <ul>
              <li>
               <strong>"UI ログの冗長性:"</strong><br/>デフォルトのログ出力か詳細なログ出力かをカスタマイズします。              </li>              
                  <li>
               <strong>"UI ログにタイムスタンプをプリント:"</strong><br/>UIログにタイムスタンプを出力するかどうかをカスタマイズします。              </li>
              <li>
               <strong>"UI ログでテキストの折り返しを有効にする:"</strong><br/>UI ログにワードラッピングを使用するかどうかをカスタマイズします。              </li>
            </ul>

            <h2 id="global_preferences_network"><a href="#global_preferences_network">ネットワーク</a></h2>
            <p>
              <img src="assets/img/global_preferences_network_jpn.png" alt="Global preferences network">
            </p>
                  <ul>
              <li>
               <strong>"接続先の Broker (ホスト名または IP アドレス):"</strong><br/>ローカルマシン上で実行されるプロセスは、常に<strong>127.0.0.1</strong>または<strong>localhost の</strong>いずれかを使用する必要があります。リモート・マシン上で動作するプロセスは、<a href="#networked_editing">Broker IPを</a>適宜<a href="#networked_editing">設定</a>する必要があります。              </li>
              <li>
               <strong>"通信ポート:"</strong><br/>Bridge と Broker 間の TCP/IP 接続に使用するポート。              </li>
              <li>
               <strong>"Bridge を Broker に接続する際のタイムアウト (ミリ秒):"</strong><br/>BridgeがBrokerに接続するときに考慮するタイムアウト。              </li>
            </ul>


            <h2 id="global_preferences_notifications"><a href="#global_preferences_notifications">通知</a></h2>
            <p>
              <img src="assets/img/global_preferences_notifications_jpn.png" alt="Global preferences notifications">
            </p>
            <p>
              ファイルへのパスは、絶対パス、またはBrokerからの相対パスのいずれかを指定できます。            </p>
            <ul>
              <li>
                       <strong>"通知を有効にする:"</strong><br/>これを有効にすると、Live++は完了した操作のトースト通知を表示します。                      </li>
              <li>
               <strong>"以下の場合、Broker ウィンドウにフォーカス:"</strong><br/>ブローカー・ウィンドウがフォーカスされるタイミングを選択できます： never、hot-reload または hot-restart 操作時、error 時、successful 操作時、または always。         </li>
                      <li>
                       <strong>"成功時にサウンドを再生:"</strong>,<strong>"成功時の通知音:"</strong><br/>コンパイルが成功したときに再生する .WAV ファイルを指定します。                      </li>
                      <li>
                       <strong>"エラー発生時にサウンドを再生:"</strong>,<strong>"エラー時の通知音:"</strong><br/>コンパイルが失敗したときに再生する .WAV ファイルを指定します。                      </li>
                  </ul>


            <h2 id="global_preferences_hot_reload"><a href="#global_preferences_hot_reload">ホットリロード</a></h2>
            <p>
              <img src="assets/img/global_preferences_hot_reload_jpn.png" alt="Global preferences hot-reload">
            </p>
                <ul>
              <li>
               <strong>"タイムアウト (ミリ秒):"</strong><br/>ホットリロード操作をスケジューリングするときに使用するミリ秒単位のタイムアウトです。タイムアウトよりも応答が長いエージェントは、ホットリロード操作を放棄します。              </li>
                    <li>
                       <strong>"不完全なモジュールをロード:"</strong><br/>これを有効にすると、不完全なモジュールがロードされ、<strong>コンパイル単位</strong>ビューに表示されます。                    </li>
                    <li>
                       <strong>"不完全なコンパイル単位をロード:"</strong><br/>これを有効にすると、未完成のコンパイランドがロードされ、<strong>コンパイル単位</strong>ビューに表示され、コンパイラ・オプションの欠落などの欠陥を検査できるようになります。                      </li>
                      <li>
                       <strong>"プロセスの終了時にパッチファイルを削除:"</strong><br/>これを有効にすると、Live++パッチに属するファイルは、対応するプロセスが終了するとすぐに削除されます。                      </li>
                      <li>
                       <strong>"ホットリロード時にログをクリア:"</strong><br/>これを有効にすると、ホット・リロード時に UI ログがクリアされます。                      </li>
                      <li>
                       <strong>"ホットリロードを呼び出すショートカット:"</strong><br/>ホットリロードを起動するためのショートカットを設定できます。                      </li>
                   </ul>


            <h2 id="global_preferences_hot_restart"><a href="#global_preferences_hot_restart">ホットリスタート</a></h2>
            <p>
              <img src="assets/img/global_preferences_hot_restart_jpn.png" alt="Global preferences hot-restart">
            </p>
            <ul>
              <li>
               <strong>"タイムアウト (ミリ秒):"</strong><br/>ホット再起動操作をスケジュールするときに使用するミリ秒単位のタイムアウトです。応答がタイムアウトより長いエージェントは、ホット再起動操作を放棄します。              </li>
              <li>
               <strong>"ホットリスタートを呼び出すショートカット:"</strong><br/>ホット再起動を起動するためのショートカットを設定できます。              </li>
            </ul>


            <h2 id="global_preferences_ide"><a href="#global_preferences_ide">IDE</a></h2>
            <p>
              <img src="assets/img/global_preferences_ide_jpn.png" alt="Global preferences IDE">
            </p>
                <ul>
                    <li>
                       <strong>"Visual Studio でモーダルダイアログを表示:"</strong><br/>これを有効にすると、ホット再起動の操作中に Visual Studio でモーダルダイアログが表示されます。これにより、Live++操作の実行中は、Visual Studioデバッガとのインタラクションが禁止されます。                      <p>
                         <img src="assets/img/vs_modal_dialog.png" alt="Modal dialog in Visual Studio">
                        </p>                      
                    </li>
                    <li>
                       <strong>"ホットリロード中はブレークポイントを有効のままにする:"</strong><br/>これを有効にすると、ホット・ロード操作中もブレークポイントが有効になります。通常、Visual Studio および Rider のブレークポイントは、プロセスが誤って停止しないように、ホット・リロード操作中は一時的に無効になります。                    </li>
                    <li>                  
                       <strong>"IDE で現在開いているファイルの最適化を切り替えるショートカット:"</strong><br/>Visual Studio または Rider で現在開いているファイルの最適化を切り替えるショートカットを設定できます。                    </li>
                </ul>


            <h2 id="global_preferences_licensing"><a href="#global_preferences_licensing">ライセンス</a></h2>
            <p>
              <img src="assets/img/global_preferences_licensing_jpn.png" alt="Global preferences licensing">
            </p>
                <ul>
                    <li>
                       <strong>"ライセンスの有効期限が近づいたら警告を表示:"</strong><br/>これを有効にすると、Broker は現在のライセンスが期限切れになるたびに警告を表示します。                    </li>
                    <li>                  
                       <strong>"残り日数が次の値に達したら警告:"</strong><br/>ライセンスが期限切れになりそうなときに何日分の警告を表示するかを設定できます。                    </li>
                </ul>
          </section>


          <header>
            <h1 id="project_preferences"><a href="#project_preferences">プロジェクト環境設定</a></h1>
            <p class="lead">プロジェクト環境設定は、Brokerメインメニューの<span class="notranslate label label-default label-custom-MM">編集 -> プロジェクトの環境設定...</span>を選択することで設定できます。これらは、Live++の動作をカスタマイズするためのプロジェクト固有の設定を提供し、任意の.jsonファイルに保存されます。</p>
          </header>

          <section>
            <h2 id="project_preferences_general"><a href="#project_preferences_general">一般</a></h2>
            <p>
              プロジェクト環境設定を使用する場合、2つのオプションがあります：            </p>
            <ul>
              <li>
                次の例に示すように、<a href="#usage_agents">エージェントを作成する</a>ときに、プロジェクト固有の .json ファイルを引数として渡します：<pre class="notranslate"><code class=" language-cpp"><span class="token comment" spellcheck="true">// create a synchronized Live++ agent, loading the required project preferences.</span>
<span class="token comment" spellcheck="true">// the path to load the preferences from can be absolute, or relative to this application.</span>
lpp<span class="token operator">::</span>LppSynchronizedAgent lppAgent <span class="token operator">=</span> lpp<span class="token operator">::</span><span class="token function">LppCreateSynchronizedAgentWithPreferencesFromFile</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span> L<span class="token string">"ThirdParty/LivePP"</span><span class="token punctuation">,</span> L<span class="token string">"Preferences/continuous_compilation.json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
              </li>
              <li>
                デフォルトの<code class="notranslate code-in-text language-cpp">lpp<span class="token operator">::</span>LppProjectPreferences</code>インスタンスを作成し、<a href="#usage_agents">エージェントを作成する</a>際の引数として渡す：<pre class="notranslate"><code class=" language-cpp"><span class="token comment" spellcheck="true">// disable unity splitting in the preferences</span>
lpp<span class="token operator">::</span>LppProjectPreferences prefs <span class="token operator">=</span> lpp<span class="token operator">::</span><span class="token function">LppCreateDefaultProjectPreferences</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
prefs<span class="token punctuation">.</span>unitySplitting<span class="token punctuation">.</span>isEnabled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// create a default Live++ agent with the project preferences</span>
lpp<span class="token operator">::</span>LppDefaultAgent lppAgent <span class="token operator">=</span> lpp<span class="token operator">::</span><span class="token function">LppCreateDefaultAgentWithPreferences</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span> L<span class="token string">"ThirdParty/LivePP"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>prefs<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
              </li>
            </ul>
            <p>
              エージェントを作成するときに、.jsonファイルへのパスも環境設定インスタンスも渡さない場合、Live++は、すべてのプロジェクト環境設定のデフォルト値を想定します。            </p>

            <p>
              <img src="assets/img/project_preferences_general_jpn.png" alt="Project preferences general">
            </p>
            <ul>
              <li>
               <strong>"ローカルな接続用に Broker を自動的に起動:"</strong><br/>これを有効にすると、Agent がターゲットアプリケーションにロードされるとすぐに、Agent はローカル接続用の Broker を自動的に起動します。              </li>
              <li>
               <strong>"Bridge から Broker への接続に失敗した場合、エラーを表示:"</strong><br/>これを有効にすると、Bridge は Broker に接続できない場合にエラーを報告します。              </li>
              <li>
               <strong>"Broker へのディレクトリ:"</strong><br/>Agent によって生成される Broker へのディレクトリを指定します。ディレクトリは、絶対ディレクトリまたは Agent からの相対ディレクトリのいずれかを指定します。              </li>
            </ul>

            <h2 id="project_preferences_hot_reload"><a href="#project_preferences_hot_reload">ホットリロード</a></h2>
            <p>
              <img src="assets/img/project_preferences_hot_reload_jpn.png" alt="Project preferences hot-reload">
            </p>
            <ul>
              <li>
               <strong>"ツールチェーン環境をキャプチャする際のタイムアウト (ミリ秒):"</strong><br/>Visual Studioのコンパイラとリンカの環境をキャプチャするときに使用するミリ秒単位のタイムアウトです。タイムアウト時間を超えて実行されたバッチファイルは、自動的に中止されます。              </li>
              <li>
               <strong>"オブジェクトファイルとして考慮されるファイル拡張子:"</strong><br/>オブジェクト・ファイルで考慮されるファイル拡張子のリスト。その他のファイル拡張子は無視されます。              </li>
              <li>
               <strong>"ライブラリファイルとして考慮されるファイル拡張子:"</strong><br/>ライブラリ ファイル用に考慮されるファイル拡張子のリスト。その他のファイル拡張子は無視されます。              </li>
              <li>
               <strong>"ソースファイルとして考慮されるフィルター:"</strong><br/>ソース・ファイルのフィルタリングに使用されるセミコロンで区切られた文字列のリスト。フィルタのいずれかを含むソース・ファイルは完全に無視されます。フィルター・チェックは、小文字のソース・パスを使用して実行されます。              </li>
              <li>
               <strong>"プレビルドの手順を有効にする:"</strong><br/>Live++ がホット・リロード操作ごとにプリビルド・ステップを実行するかどうかを指定します。              </li>
              <li>
               <strong>"プレビルドの手順実行可能ファイル:"</strong><br/>プリビルドステップを実行するときに呼び出される実行ファイルを選択できます。              </li>
              <li>
               <strong>"プレビルドの手順作業ディレクトリ:"</strong><br/>プリビルドステップを実行するときに使用する作業ディレクトリーを選択できます。              </li>
              <li>
               <strong>"プレビルドの手順コマンドラインのオプション:"</strong><br/>プリビルド・ステップを実行するときに呼び出される実行ファイルに渡されるコマン ド・ライン・オプションを指定します。              </li>
              <li>
               <strong>"停止したプロセスのコンパイルフックを呼び出す:"</strong><br/>Live++ が停止したプロセスのコンパイル・フックを呼び出すかどうかを指定します。              </li>
              <li>
               <strong>"停止したプロセスのリンクフックを呼び出す:"</strong><br/>Live++ が停止したプロセスのリンク フックを呼び出すかどうかを指定します。              </li>
              <li>
               <strong>"停止したプロセスのホットリロードフックを呼び出す:"</strong><br/>停止したプロセスに対して Live++ がホット リロード フックを呼び出すかどうかを指定します。              </li>
            </ul>

            <div class="callout callout-info-MM" role="alert">
              <h4>メモ</h4>
              <p>Live++が停止したプロセスに対してフックを呼び出すことを許可することは、デッドロックにつながる可能性があるため、潜在的に危険な操作です。停止中のプロセスでは、Live++は常に、プロセス内の他のすべてのスレッドが一時停止している間に、その受信スレッドからフックを呼び出します。停止中のスレッドが同じプリミティブを保持している間に、いずれかのフックがミューテックスなどの同期プリミティブをロックしようとすると、デッドロックが発生します。</p>
              <p>したがって、フックの実装は、どのスレッドもいつでもサスペンドされる可能性があるという前提で動作しなければならない。</p>
            </div>

            <div class="callout callout-info-MM" role="alert">
              <h4>例</h4>
              <p>Live++には<strong>"14_PreBuildStep"</strong>というサンプルが同梱されており、プリビルド・ステップの設定方法が示されています。  </p>
            </div>


            <h2 id="project_preferences_compiler"><a href="#project_preferences_compiler">コンパイラ</a></h2>
            <p>
              <img src="assets/img/project_preferences_compiler_jpn.png" alt="Project preferences compiler">
            </p>
            <p>
              ファイルへのパスには、絶対パスとBrokerからの相対パスがあります。            </p>
            <ul>
              <li>
               <strong>"コンパイラーツールチェーン環境をキャプチャ:"</strong><br/>Live++がvcvars*.batコンパイラー・ツールチェーン環境を検索して使用するかどうかを設定します。この設定を無効にすると、カスタム ビルド システムに便利です。              </li>
              <li>
               <strong>"コンパイラーパスをオーバーライド:"</strong><br/>PDB で見つかったコンパイラ・パスを上書きして、Live++ がファイルを再コンパイルするときに、代わりにこのコンパイラを使用するようにします。カスタム ビルド システムを使用する場合にのみ必要です。              </li>
              <li>
               <strong>"オーバーライドされたコンパイラーパスをフォールバックのみとして使用:"</strong><br/>これを有効にすると、PDB で検出されたコンパイラが使用できない場合にのみ、オーバーライドされたコンパイラ・パスが使用されます。              </li>
              <li>
               <strong>"追加のコマンドラインオプション:"</strong><br/>パッチを作成するときにコンパイラに追加のオプションを渡すことができます。              </li>
              <li>
               <strong>"プリコンパイル済みヘッダー PDB を強制的に使用:"</strong><br/>これを有効にすると、再コンパイル時に各翻訳ユニットが対応するプリコンパイルされたヘッダーと同じPDBを使用するようにLive++を強制します。これは、Incredibuildをリモートエージェントとプリコンパイルされたヘッダーファイルで使用した場合に発生するコンパイラーエラーC2858の回避策として意図されています。              </li>
              <li>
               <strong>""-showIncludes" コンパイラーオプションを削除:"</strong><br/>これを有効にすると、一部のビルドシステムで使用されている<strong>-showIncludes</strong>コンパイラーオプションが、コードの再コンパイル時に削除されます。              </li>
              <li>
               <strong>""-sourceDependencies" コンパイラーオプションを削除:"</strong><br/>これを有効にすると、一部のビルド・システムで使用されている<strong>-sourceDependencies</strong>コンパイラー・オプションが、コードの再コンパイル時に削除されます。              </li>
            </ul>


            <h2 id="project_preferences_linker"><a href="#project_preferences_linker">リンカ</a></h2>
            <p>
              <img src="assets/img/project_preferences_linker_jpn.png" alt="Project preferences linker">
            </p>
            <p>
              ファイルへのパスには、絶対パスと Broker からの相対パスを指定できます。            </p>
                <ul>
                    <li>
                       <strong>"リンカーツールチェーン環境をキャプチャ:"</strong><br/>Live++ が vcvars*.bat リンカー・ツールチェーン環境を検索して使用するかどうかを設定します。この設定を無効にすると、カスタム ビルド システムに便利です。                    </li>
                    <li>
                       <strong>"リンカーパスをオーバーライド:"</strong>,<strong>"オーバーライドされたリンカーパス:"</strong><br/>ファイルを再コンパイルするときに、Live++が代わりにこのリンカーを使用するように、PDBで見つかったリンカー パスを上書きします。カスタム ビルド システムを使用する場合にのみ必要です。                    </li>
                    <li>
                       <strong>"オーバーライドされたリンカーパスをフォールバックのみとして使用:"</strong><br/>これを有効にすると、PDB で検出されたリンカが使用できない場合にのみ、オーバーライドされたリンカ・パスが使用されます。                    </li>
                    <li>
                       <strong>"追加のコマンドラインオプション:"</strong><br/>パッチを作成するときにリンカに追加のオプションを渡すことができます。                    </li>
              <li>
               <strong>"インポートライブラリの作成を抑制 (/NOIMPLIB):"</strong><br/>パッチDLLを作成するとき、リンカによっては、シンボルをエクスポートしないDLLであっても、インポート・ライブラリの作成を要求するものがあります。Live++はこれらのインポート・ライブラリを必要としませんが、一部の古いリンカは<strong>/NOIMPLIB</strong>オプションを理解しません。              </li>
                </ul>


            <h2 id="project_preferences_exceptions"><a href="#project_preferences_exceptions">例外</a></h2>
            <p>
              <img src="assets/img/project_preferences_exceptions_jpn.png" alt="Project preferences exceptions">
            </p>
            <ul>
              <li>
               <strong>"例外ハンドラーを有効にする:"</strong><br/>これを有効にすると、Live++は<a href="#tools_hot_fix">Hot-Fix</a>機能用の例外ハンドラをインストールします。              </li>
              <li>
               <strong>"例外ハンドラーを以下としてインストール:"</strong><br/>例外ハンドラを<a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-addvectoredexceptionhandler" target="_blank">最初のハンドラとして</a>インストール<a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-addvectoredexceptionhandler" target="_blank">するか、最後のハンドラとして</a>インストールするかを選択できます。              </li>
            </ul>


            <h2 id="project_preferences_continuous_compilation"><a href="#project_preferences_continuous_compilation">連続コンパイル</a></h2>
            <p>
              <img src="assets/img/project_preferences_continuous_compilation_jpn.png" alt="Project preferences continuous compilation">
            </p>
            <p>
              ディレクトリは、絶対ディレクトリ、または Broker からの相対ディレクトリのいずれかを指定できます。            </p>
            <ul>
              <li>
               <strong>"連続コンパイルを有効にする:"</strong><br/>連続コンパイルを有効にすると、Live++は指定されたディレクトリ（およびそのサブディレクトリ）の変更通知を待機し、タイムアウトが経過すると、変更があれば自動的にコンパイルします。              </li>
              <li>
               <strong>"監視するディレクトリ:"</strong><br/>連続コンパイル使用時に変更を監視するディレクトリを設定します。              </li>
              <li>
               <strong>"変更をリッスンする際のタイムアウト (ミリ秒):"</strong><br/>変更通知を待機しているとき、Live++はタイムアウトに達するまで後続の変更を待機します。              </li>
            </ul>

            <div class="callout callout-info-MM" role="alert">
              <h4>注記</h4>
              <p>Live++は、監視対象のディレクトリに<strong>ある</strong>ファイルへの変更が検出されると、コンパイル処理を開始します。監視するディレクトリを適宜選択してください。</p>
            </div>

            <div class="callout callout-info-MM" role="alert">
              <h4>例</h4>
              <p>Live++には、これを示す<strong>"02_ContinuousCompilation"</strong>というサンプルが同梱されています。</p>
            </div>


            <h2 id="project_preferences_virtual_drive"><a href="#project_preferences_virtual_drive">仮想ドライブ</a></h2>
            <p>
              一部のビルド・システムでは、ビルド中に使用するすべてのツールが同じパスを参照できるように、コードのビルド時に一時的に仮想ドライブを設定します。しかし、コンパイルされたモジュールのPDBファイルには、この仮想ドライブ上のパスが含まれることになり、アプリケーションを起動してLive++を使用するときに、このパスが使用できなくなることがあります。以下のオプションで仮想ドライブを設定できます：            </p>
            <p>
              <img src="assets/img/project_preferences_virtual_drive_jpn.png" alt="Project preferences virtual drive">
            </p>
            <ul>
              <li>
                <strong>"ドライブ (例:Z:):"</strong><br/>指定したディレクトリにマッピングされる仮想ドライブの文字を指定します。文字列の後には、"Z:"（引用符なし）のようにコロンを付ける必要があります。              </li>
              <li>
               <strong>"ディレクトリ:"</strong><br/>上記で指定されたドライブ文字にマップされるディレクトリを設定できま す (例<strong>: C:\MyPath</strong>)。              </li>
            </ul>


            <h2 id="project_preferences_unity_splitting"><a href="#project_preferences_unity_splitting">ユニティ分割</a></h2>
            <p>
              <img src="assets/img/project_preferences_unity_splitting_jpn.png" alt="Project preferences unity splitting">
            </p>
            <ul>
              <li>
               <strong>"統合/Jumbo/BLOB/Amalgamated ファイルの分割を有効にする:"</strong><br/>これを有効にすると、Live++はunityファイルの分割を行います。              </li>
              <li>
               <strong>"ソースファイルの数が次の値になったら分割:"</strong><br/>Live++ が分割を試みる前に、unity ファイルに含まれていなければならない .cpp ファイルの最小数を指定します。例えば、このしきい値を 3 に設定すると、3 つ以上の .cpp ファイルを含む unity ファイルだけが分割されます。              </li>
              <li>
               <strong>"分割として考慮される C/C++ ファイル拡張子:"</strong><br/>unity ファイルを分割するときに C/C++ ファイルとして扱われるファイル拡張子のリスト。              </li>
            </ul>
          </section>


          <header>
            <h1 id="API"><a href="#API">API</a></h1>
            <p class="lead">Live++は物事を理解するのは得意ですが、魔法は使えません。APIは特定のシナリオを動作させるために必要なヘルプを提供することができ、CとC++の両方から使用できるいくつかのヘッダーファイルとして出荷されています。しかし、クライアント・コードが必要とするのは、どのプラットフォーム、どの言語でも、<a href="#directory_structure">特定のヘッダー・ファイル1つだけ</a>である。            </p>
          </header>

          <section>
            <h2 id="API_naming_convention"><a href="#API_naming_convention">命名規則</a></h2>
            <p>
              一般的に、全ての API シンボルは共通の接頭辞を持ちます。すべてのマクロは<strong>LPP_</strong> で始まり、関数は<strong>Lpp</strong> で始まります。C++では、名前の衝突を減らすために、すべての関数は<strong>lpp</strong>名前空間の一部です。            </p>


            <h2 id="API_flavours"><a href="#API_flavours">フレーバー</a></h2>
            <p>
              ディレクトリやパスを必要とするすべてのAPIは、2つのフレーバーがあります：引数として<code class="notranslate code-in-text language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span></code>取るANSIバージョンと、引数として<code class="notranslate code-in-text language-cpp"><span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span></code>取るワイド・キャラクタ・バージョンです。
            </p>


            <h2 id="API_versioning"><a href="#API_versioning">バージョン管理</a></h2>
            <p>Live++では、ヘッダーファイルとDLLが同期しないことがないように、簡単なバージョン管理スキームを使用しています。これを実現するために、ヘッダーファイルは、DLLによってエクスポートされることを期待するAPIのバージョンを定義します：</p>
<pre class="notranslate"><code class=" language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> LPP_VERSION "2.0.0"</span></code></pre>


            <p>内部的には、DLLはビルドされたAPIのバージョンを返す関数を公開しています：</p>
<pre class="notranslate"><code class=" language-cpp">LPP_API <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">LppGetVersion</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

            <p>さらに、DLL は内部的にバージョンチェックを行い、API と DLL のバージョンが一致するかどうかを返す関数を提供します：</p>
<pre class="notranslate"><code class=" language-cpp">LPP_API <span class="token keyword">bool</span> <span class="token function">LppCheckVersion</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> expectedVersion<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

            <p><a href="#creating_default_agent">エージェントを作成する</a>場合、API と DLL のバージョンが常に一致するように、これらのチェックが自動的に実行されます。</p>


            <h2 id="API_agent_validation"><a href="#API_agent_validation">エージェントの検証</a></h2>
            <p>
              エージェントの作成が成功したかどうかを確認したい場合、以下のAPIを使用できます：              
            </p>

            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>API</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="60%" class="notranslate"><code class=" language-cpp"><span class="token keyword">bool</span> lpp<span class="token operator">::</span><span class="token function">LppIsValidDefaultAgent</span><span class="token punctuation">(</span><span class="token keyword">const</span> LppDefaultAgent<span class="token operator">*</span> <span class="token keyword">const</span> agent<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>指定されたデフォルトエージェントが有効かどうかを返します。</td>
                  </tr>

                  <tr>
                    <td width="60%" class="notranslate"><code class=" language-cpp"><span class="token keyword">bool</span> lpp<span class="token operator">::</span><span class="token function">LppIsValidSynchronizedAgent</span><span class="token punctuation">(</span><span class="token keyword">const</span> LppSynchronizedAgent<span class="token operator">*</span> <span class="token keyword">const</span> agent<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>指定された同期エージェントが有効かどうかを返します。</td>
                  </tr>
                </tbody>
              </table>
            </div>


            <h2 id="API_connection_callback"><a href="#API_connection_callback">接続コールバック</a></h2>
            <p>
              コードベースやエンジンとのより深い統合のために、Agent、Bridge、Broker の接続が成功したかどうかをチェックするために、以下のオプション API を使用したい場合があります：            </p>

            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>API</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="62%" class="notranslate"><code class=" language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token function">LppOnConnectionCallback</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> context<span class="token punctuation">,</span> lpp<span class="token operator">::</span>LppConnectionStatus status<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>コールバック関数タイプ。</td>
                  </tr>

                  <tr>
                    <td width="62%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> Agent<span class="token operator">::</span><span class="token function">OnConnection</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> context<span class="token punctuation">,</span> lpp<span class="token operator">::</span>LppOnConnectionCallback<span class="token operator">*</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>

                    <td>AgentとBridge/Brokerの接続が試行された後、ユーザが指定したコンテキストと接続ステータスで指定されたコールバックを呼び出します。</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <p>
              この API はノンブロッキングでスレッドセーフであることに注意してください。Live++は、内部的に接続試行が行われる前または後にAPIが呼び出されたかに関係なく、常に最終接続ステータスでコールバックを1回呼び出します。            </p>


            <h2 id="API_hooks"><a href="#API_hooks">フック</a></h2>
            <p>
              フックを使用すると、コンパイルの進行中にプログレス・バーやメッセージ・ボックスなどを表示することで、Live++をエンジン/フレームワーク/アプリケーションに深く統合することができます。また、フックを使用して、コンパイルやリンクに関する情報やエラーを出力したり、構造的な変更をサポートすることもできます。            </p>

            <div class="callout callout-info-MM" role="alert">
              <h4>備考</h4>
              <p>
                プロセスが<a href="#halted_processes">デバッガに保持されている</a>場合（ブレークポイントなど）、Live++は、<a href=#project_preferences_hot_reload>プロジェクト環境</a>設定からオプトインしない限り、インストールされているフックを呼び出しません。              </p>
            </div>


            <h3 id="API_compile_hooks"><a href="#API_compile_hooks">コンパイル・フック</a></h3>
            <p>コンパイル・フックを使用すると、ホット・リロード・コンパイル・プロセスにフックして、コンパイル・プロセスのさまざまな段階について通知を受けることができます。以下のコンパイルフックがサポートされています：</p>
            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>API</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="50%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">PrecompileHook</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LppPrecompileHookId<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledModulePath<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> filesToCompileCount<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>コンパイル開始前に呼び出されるフックを登録します。<br><code class="notranslate language-cpp"><span class="token function">LPP_PRECOMPILE_HOOK</span><span class="token punctuation">(</span>functionName<span class="token punctuation">)</span></code>マクロで登録します。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">PostcompileHook</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LppPostcompileHookId<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledModulePath<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> filesToCompileCount<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>コンパイル終了後に呼ばれるフックを登録します。<br><code class="notranslate language-cpp"><span class="token function">LPP_POSTCOMPILE_HOOK</span><span class="token punctuation">(</span>functionName<span class="token punctuation">)</span></code>マクロで登録します。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">CompileStartHook</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LppCompileStartHookId<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledModulePath<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledSourcePath<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>ファイルのコンパイル開始時に呼ばれるフックを登録します。<br><code class="notranslate language-cpp"><span class="token function">LPP_COMPILE_START_HOOK</span><span class="token punctuation">(</span>functionName<span class="token punctuation">)</span></code>マクロで登録します。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">CompileSuccessHook</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LppCompileSuccessHookId<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledModulePath<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledSourcePath<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>ファイルのコンパイルが成功したときに呼ばれるフックを登録します。<br><code class="notranslate language-cpp"><span class="token function">LPP_COMPILE_SUCCESS_HOOK</span><span class="token punctuation">(</span>functionName<span class="token punctuation">)</span></code>マクロで登録します。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">CompileErrorHook</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LppCompileErrorHookId<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledModulePath<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledSourcePath<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> compilerOutput<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>ファイルのコンパイルが失敗したときに呼ばれるフックを登録します。<br><code class="notranslate language-cpp"><span class="token function">LPP_COMPILE_ERROR_HOOK</span><span class="token punctuation">(</span>functionName<span class="token punctuation">)</span></code>マクロで登録します。</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
              ほとんどのフックは、同様の関数シグネチャを期待するので、最初の引数として期待される異なる<code class="notranslate code-in-text language-cpp">lpp<span class="token operator">::</span>Lpp<span class="token operator">*</span>HookId</code>値は、追加の型安全性と保護を提供するためだけに役立ちます。            </p>
            <p>
             <code class="notranslate code-in-text language-cpp"><span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledModulePath</code>と<code class="notranslate code-in-text language-cpp"><span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledSourcePath</code>引数は、それぞれリコンパイルされたモジュールとソースファイルへの絶対パスを提供します。            </p>


            <h3 id="API_link_hooks"><a href="#API_link_hooks">リンクフック</a></h3>
            <p>リンク・フックを使用すると、ホット・リロード・リンク・プロセスにフックし、リンク・プロセスのさまざまな段階について通知を受けることができます。以下のリンクフックがサポートされています：</p>
            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>API</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="50%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">LinkStartHook</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LppLinkStartHookId<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledModulePath<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>リンク開始時に呼び出されるフックを登録します。<br><code class="notranslate language-cpp"><span class="token function">LPP_LINK_START_HOOK</span><span class="token punctuation">(</span>functionName<span class="token punctuation">)</span></code>マクロで登録します。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">LinkSuccessHook</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LppLinkSuccessHookId<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledModulePath<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>リンクが成功したときに呼び出されるフックを登録します。<br><code class="notranslate language-cpp"><span class="token function">LPP_LINK_SUCCESS_HOOK</span><span class="token punctuation">(</span>functionName<span class="token punctuation">)</span></code>マクロで登録します。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">LinkErrorHook</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LppLinkErrorHookId<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledModulePath<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> linkerOutput<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>リンクが失敗したときに呼ばれるフックを登録します。<br><code class="notranslate language-cpp"><span class="token function">LPP_LINK_ERROR_HOOK</span><span class="token punctuation">(</span>functionName<span class="token punctuation">)</span></code>マクロで登録します。</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
              ほとんどのフックは、同様の関数シグネチャを期待するので、最初の引数として期待される異なる<code class="notranslate code-in-text language-cpp">lpp<span class="token operator">::</span>Lpp<span class="token operator">*</span>HookId</code>値は、追加の型安全性と保護を提供するためだけに役立ちます。            </p>
            <p>
             <code class="notranslate code-in-text language-cpp"><span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledModulePath</code>引数は、リコンパイルされたモジュールへの絶対パスを提供します。            </p>

            <div class="callout callout-info-MM" role="alert">
              <h4>例</h4>
              <p>Live++には、フックを実演する<strong>"06_Hooks"</strong>というサンプルが同梱されています。</p>
            </div>


            <h3 id="API_hot_reload_hooks"><a href="#API_hot_reload_hooks">ホット・リロード・フック</a></h3>
            <p>ホット-リロードフックを使用すると、ホット-リロードプロセスにフックして、パッチ操作のさまざまな段階について通知を受けることができます。以下のホットリロードフックがサポートされています：</p>
            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>API</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="50%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">PrePatchHook</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LppHotReloadPrepatchHookId<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledModulePath<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span> modifiedFiles<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> modifiedFilesCount<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span> modifiedClassLayouts<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> modifiedClassLayoutsCount<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>パッチがターゲットアプリケーションにロードされる前に呼び出されるフックを登録します。<br><code class="notranslate language-cpp"><span class="token function">LPP_HOTRELOAD_PREPATCH_HOOK</span><span class="token punctuation">(</span>functionName<span class="token punctuation">)</span></code>マクロで登録します。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">PostPatchHook</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LppHotReloadPostpatchHookId<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledModulePath<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span> modifiedFiles<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> modifiedFilesCount<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span> modifiedClassLayouts<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> modifiedClassLayoutsCount<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>パッチがターゲットアプリケーションにロードされた後に呼び出されるフックを登録します。<br><code class="notranslate language-cpp"><span class="token function">LPP_HOTRELOAD_POSTPATCH_HOOK</span><span class="token punctuation">(</span>functionName<span class="token punctuation">)</span></code>マクロで登録します。</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <p>
              両方のフックは同じ関数シグネチャを期待するので、最初の引数として期待される異なる<code class="notranslate code-in-text language-cpp">lpp<span class="token operator">::</span>Lpp<span class="token operator">*</span>HookId</code>値は、追加の型安全性と保護を提供するためだけに役立ちます。            </p>
            <p>
             <code class="notranslate code-in-text language-cpp"><span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> recompiledModulePath</code>引数は、リコンパイルされたモジュールへの絶対パスを提供します。            </p>
            <p>
             <code class="notranslate code-in-text language-cpp"><span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span> modifiedFiles<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> modifiedFilesCount</code>引数は、変更されたファイルの絶対パスの配列を提供する。            </p>

            <div class="callout callout-info-MM" role="alert">
              <h4>注意</h4>
              <p><code class="notranslate code-in-text language-cpp"><span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span> modifiedClassLayouts<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> modifiedClassLayoutsCount</code>引数は、最終的には変更されたクラス・レイアウトの名前の配列を提供する予定ですが、この機能はまだ利用できません。</p>
            </div>

            <div class="callout callout-info-MM" role="alert">
              <h4>例</h4>
              <p><code class="notranslate code-in-text language-cpp"><span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span> modifiedFiles<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> modifiedFilesCount</code>引数を使用することにより、Live++と一緒に出荷されるすべてのサンプルには、特定のファイルが変更されたときにクラス・インスタンスの破棄と再構築をサポートする、パッチ前およびパッチ後のフックが含まれています。</p>
            </div>


            <h3 id="API_global_hot_reload_hooks"><a href="#API_global_hot_reload_hooks">グローバル・ホット・リロード・フック</a></h3>
            <p>グローバル・ホット・リロード・フックを使用すると、ホット・リロード・プロセスにフックし、ホット・リロード操作の開始と終了について通知を受けることができます。以下のグローバルホットリロードフックがサポートされています：</p>
            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>API</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="50%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">GlobalHotReloadStart</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LppGlobalHotReloadStartHookId<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>ホットリロード操作の開始後に呼び出されるグローバルフックを登録します。<br><code class="notranslate language-cpp"><span class="token function">LPP_GLOBAL_HOTRELOAD_START_HOOK</span><span class="token punctuation">(</span>functionName<span class="token punctuation">)</span></code>マクロで登録します。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">GlobalHotReloadEnd</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LppGlobalHotReloadEndHookId<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>ホットリロード操作が終了する前に呼び出されるグローバルフックを登録します。<br><code class="notranslate language-cpp"><span class="token function">LPP_GLOBAL_HOTRELOAD_END_HOOK</span><span class="token punctuation">(</span>functionName<span class="token punctuation">)</span></code>マクロで登録します。</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <p>
              両方のフックは同じ関数シグネチャを期待するので、最初の引数として期待される異なる<code class="notranslate code-in-text language-cpp">lpp<span class="token operator">::</span>Lpp<span class="token operator">*</span>HookId</code>値は、追加の型安全性と保護を提供するためだけに役立ちます。            </p>

            <div class="callout callout-info-MM" role="alert">
              <h4>注意</h4>
              他のフックとは異なり、これらのフックはグローバルとみなされます。これは、登録されたモジュールの変更が検出されるたびに、実際にどのモジュールがフックを含んでいるかに関係なく、常に呼び出されることを意味します。            </div>


            <h2 id="API_structural_change"><a href="#API_structural_change">構造的変更</a></h2>
            <p>以下の操作は「構造的変更」とみなされます：              <ul>
                <li>クラス宣言のメモリ・レイアウトの変更：</li>
                  <ul>
                    <li>基底クラスの追加や削除</li>
                    <li>非静的データ・メンバの追加と削除</li>
                    <li>非静的データ・メンバの順序を変更する。</li>
                  </ul>
                <li>仮想関数テーブルのレイアウトや内容の変更：</li>
                  <ul>
                    <li>多相基底クラスの追加と削除</li>
                    <li>仮想関数の追加と削除</li>
                    <li>仮想関数の順序の変更</li>
                    <li>仮想関数のシグネチャの変更</li>
                  </ul>
              </ul>
            </p>
            <p>
              既存のコードとデータに構造的な変更を加える場合、Live++は、新しいコードが古いメモリ・レイアウトに割り当てられ格納されている既存のデータと正しく連動できるようにする必要があります。そのためには、既存のオブジェクトのデータを古いメモリ・レイアウトから新しいメモリ・レイアウトに移行させる必要がありますが、これは<a href="#API_hot_reload_hooks">パッチ前およびパッチ後のホット・リロード・フックを</a>使用することで実現できます。            </p>            
            <p>フック・ステートメントはグローバル・スコープのどこにでも置くことができ、自動的に呼び出されます。フック文はグローバルスコープ内のどこにでも書くことができ、自動的に呼び出されます。フックは翻訳単位であればいくつでも追加することができます。</p>
            <p>以下は、パッチ間のデータ移行を行う方法を簡略化した例です：</p>
            
<pre class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">MyOwnPrePatchHook</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LppHotReloadPrepatchHookId<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  serialization<span class="token operator">::</span><span class="token function">SerializeAndDeleteObjects</span><span class="token punctuation">(</span>g_allObjects<span class="token punctuation">,</span> g_buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">MyOwnPostPatchHook</span><span class="token punctuation">(</span>lpp<span class="token operator">::</span>LppHotReloadPostpatchHookId<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  serialization<span class="token operator">::</span><span class="token function">CreateAndSerializeObjects</span><span class="token punctuation">(</span>g_allObjects<span class="token punctuation">,</span> g_buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">LPP_HOTRELOAD_PREPATCH_HOOK</span><span class="token punctuation">(</span>MyOwnPrePatchHook<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">LPP_HOTRELOAD_POSTPATCH_HOOK</span><span class="token punctuation">(</span>MyOwnPostPatchHook<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
            <p>基本的な考え方はいつも同じです：              <ol>
                <li>既存のオブジェクトのデータ・メンバーをメモリにシリアライズする。</li>
                <li>オブジェクトを削除する。</li>
                <li>新しいクラス・レイアウトを使用してオブジェクトを再作成する。</li>
                <li>データ・メンバーをメモリから新しいオブジェクトにシリアライズする。</li>
              </ol>
            </p>
            <p>これが難しいか簡単かは、使用するセットアップやエンジンによって異なります。また、パッチ後のフックで現在のレベルを再起動またはリロードするなど、他の選択肢を検討することもできます。このような特殊なユースケースを可能にするために、フックをどのように使用するかは自由です。</p>

            <div class="callout callout-info-MM" role="alert">
              <h4>重要</h4>
              <p>いくつかのオブジェクトが使用中にメモリレイアウトが変更されないようにするために、<a href="#creating_synchronized_agent">同期エージェントを</a>使用することを強くお勧めします。スタック上に作成されたオブジェクトは、新しいクラスレイアウトに移行できないことに留意してください。</p>
            </div>

            <div class="callout callout-info-MM" role="alert">
              <h4>例</h4>
              <p>Live++と一緒に出荷されるすべてのサンプルは、特定のファイルが変更されたときにデータ移行をサポートするホット・リロード・フックを含んでいます。</p>
            </div>


            <h2 id="API_applying_preferences"><a href="#API_applying_preferences">環境設定の適用</a></h2>
            <p>必要であれば、以下のAPIを使用して、Live++のグローバル環境設定をプログラムで適用することができます：</p>
            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>API</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="70%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> Agent<span class="token operator">::</span><span class="token function">SetBoolPreferences</span><span class="token punctuation">(</span>LppBoolPreferences preferences<span class="token punctuation">,</span> <span class="token keyword">bool</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td><code class="notranslate code-in-text language-cpp">LppBoolPreferences</code>列挙群から任意のブール環境設定を設定します。</td>
                  </tr>
                  <tr>
                    <td width="70%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> Agent<span class="token operator">::</span><span class="token function">SetIntPreferences</span><span class="token punctuation">(</span>LppIntPreferences preferences<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td><code class="notranslate code-in-text language-cpp">LppIntPreferences</code>列挙から任意の整数環境設定を設定します。</td>
                  </tr>
                  <tr>
                    <td width="70%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> Agent<span class="token operator">::</span><span class="token function">SetStringPreferences</span><span class="token punctuation">(</span>LppStringPreferences preferences<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td><code class="notranslate code-in-text language-cpp">LppStringPreferences</code>列挙型から任意の文字列環境設定を設定します。</td>
                  </tr>
                  <tr>
                    <td width="70%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> Agent<span class="token operator">::</span><span class="token function">SetShortcutPreferences</span><span class="token punctuation">(</span>LppShortcutPreferences preferences<span class="token punctuation">,</span> <span class="token keyword">int</span> virtualKeyCode<span class="token punctuation">,</span> <span class="token keyword">int</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td><code class="notranslate code-in-text language-cpp">LppShortcutPreferences</code>列挙型から任意のショートカット環境設定を設定します。</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <p>
             <code class="notranslate code-in-text language-cpp">LppBoolPreferences</code>,<code class="notranslate code-in-text language-cpp">LppIntPreferences</code>,<code class="notranslate code-in-text language-cpp">LppStringPreferences</code>,<code class="notranslate code-in-text language-cpp">LppShortcutPreferences</code>列挙型の各値は、<a href="#global_preferences">グローバル環境設定の</a>ちょうど1つのオプションに対応します。列挙型は<strong>LPP_API_Preferences.h</strong> に含まれており、列挙型の値には説明不要な名前が付けられています。            </p>


            <h2 id="API_logging_to_the_UI"><a href="#API_logging_to_the_UI">UI へのログ記録</a></h2>
            <p>Live++ では、以下の API を使用して Broker UI にメッセージをログ記録できます：</p>

            <div class="table-responsive">
              <table class="table table-bordered table-striped">
                <thead>
                  <tr>
                    <th>API</th>
                    <th>説明</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td width="50%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> Agent<span class="token operator">::</span><span class="token function">LogMessageANSI</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>Broker UI にログを送信します。</td>
                  </tr>
                  <tr>
                    <td width="50%" class="notranslate"><code class=" language-cpp"><span class="token keyword">void</span> Agent<span class="token operator">::</span><span class="token function">LogMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> <span class="token keyword">const</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span></code></td>
                    <td>Broker UI にログを送信します。</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>


          <header>
            <h1 id="limitations"><a href="#limitations">制限事項</a></h1>
            <p class="lead">Live++の現在のバージョンには、注意すべきいくつかの小さな制限があります。ただし、特に断りのない限り、これらはLive++インフラストラクチャの基本的な制限ではなく、計画されているがまだ利用できない機能であることに留意してください。Live++は、将来のアップデートで、これらの制限を最終的に解除する予定です。</p>
          </header>

          <section>
            <h2 id="limitation_overhead"><a href="#limitation_overhead">オーバーヘッド</a></h2>
            <p>
              Live++コード・パッチがビルドおよびインストールされていない限り、Live++による実行時オーバーヘッドは、各関数の前に数バイトの未使用バイトを挿入する<a href="#linker_settings">/FUNCTIONPADMINリンカ・オプションによる</a>ものだけです。しかし、これによるパフォーマンスへの影響は、測定可能であるとしても、ごくわずかです。            </p>
            <p>
             <a href="https://docs.microsoft.com/en-us/cpp/build/reference/incremental-link-incrementally" target="_blank">インクリメンタルリンクで</a>ビルドされたモジュールの場合、Live++は自動的にインクリメンタルリンクサンクを使用し、関数アドレスを直接パッチします。この場合、Live++を使用してパッチを当てた関数は、追加のオーバーヘッドをまったく発生させません。            </p>
            <p>
              それ以外のすべての場合、関数はホットパッチ技法を使用してパッチされます。ホットパッチ技法では、2バイトの短いジャンプが1回と、新しい関数への相対ジャンプが1回行われます。            </p>


            <h2 id="limitation_breakpoints"><a href="#limitation_breakpoints">Visual Studio におけるブレークポイント</a></h2>
            <p>
              Live++によってホット・ロードされたソース・ファイルに新しいブレークポイントを設定すると、Visual Studioデバッガは、対応するソース・ファイルを含むすべてのパッチにこのブレークポイントを適用しようとします。これは、特に既存のソース ファイルに新しいコード行を追加した後、すぐに混乱する可能性があります：            </p>
            <p>
              <img src="assets/img/visual_studio_breakpoints.png" alt="Visual Studio breakpoints">
            </p>
            <p>
              上の画像でわかるように、<strong>Cube.cpp の 20 行</strong>目に新しいブレークポイントを設定すると、デバッガは<strong>21 行目と 22 行目にも</strong>追加のブレークポイントを設定します。古いコードが実際にヒットされることはないため、ブレークポイントは期待通りに機能しますが、インジケータ・マージンの赤い点は誤解を招く可能性があります。            </p>
            <p>
              これを軽減するには、Visual Studio の<span class="notranslate label label-default label-custom-MM">Tools -> Options... -> Debugging -> General</span>で<span class="notranslate label label-default label-custom-MM">Require source files to exactly match the original version</span>を有効にすることをお勧めします。
            </p>


            <h2 id="limitation_global_variables"><a href="#limitation_global_variables">デバッガーでのグローバル変数</a></h2>
            <p>
              ホット・ロードされたソース・ファイルでデバッガーに侵入すると、デバッガーは通常、グローバル変数と静的変数の値を表示できません。これは、パッチコードがダイナミックライブラリから注入されるのに対して、これらの変数がオリジナルの実行ファイルに Live されていることが原因です。              
            </p>
            <p>
              これを回避するために、Visual Studio と Rider の両方は、モジュールのコンテキストをデバッガに伝えることができる<a href="https://learn.microsoft.com/en-us/visualstudio/debugger/context-operator-cpp" target="_blank">Context Operator</a>をサポートしています。            </p>
            <p>
              例を挙げると、<code class="notranslate language-cpp code-in-text">MyApplication<span class="token punctuation">.</span>exe</code>という名前のアプリケーションの<code class="notranslate language-cpp code-in-text">globalNamespace</code>という名前空間に含まれる<code class="notranslate language-cpp code-in-text">g_globalInteger</code>という名前のグローバル変数は、<code class="notranslate language-cpp code-in-text"><span class="token punctuation">{</span><span class="token punctuation">,</span><span class="token punctuation">,</span>MyApplication<span class="token punctuation">.</span>exe}<span class="token punctuation">globalNamespace</span><span class="token operator">::</span>g_globalInteger</code> としてウォッチ・ウィンドウに追加できます。            </p>

            <h2 id="limitation_functions_on_the_stack"><a href="#limitation_functions_on_the_stack">スタック上の関数</a></h2>
            <p>
              Live++ではコード・パッチがどのように動作するかによって、現在スタック上にある関数は、そのコード変更を観察する前に再入力する必要があります。実際には、これが問題になることはほとんどなく、Live++でインライン関数を正しく処理したり、関数に新しいスタック変数を導入したりすることができます。            </p>
            <div class="callout callout-info-MM" role="alert">
              <h4>注</h4>
              <p>これはLive++が使用するパッチ・メカニズム固有の制限であり、変更することはできません。</p>
            </div>


            <h2 id="limitation_thread_local_storage"><a href="#limitation_thread_local_storage">スレッドローカル記憶域</a></h2>
            <p>スレッドローカル記憶域変数を<strong>使用する</strong>ことは問題ありませんが、スレッドローカル記憶域に<strong>新しい</strong>グローバル変数や静的変数を<strong>導入する</strong>ことは現在サポートされていません。            </p>


            <h2 id="limitation_clang_dynamic_initializers"><a href="#limitation_clang_dynamic_initializers">Clang++での動的初期化子</a></h2>
            <p>Clang++ でコンパイルする場合、動的イニシャライザを必要とする新しいグローバル変数やスタティック変数を導入することはサポートされていません。Live++ で再コンパイルしたパッチでは、動的イニシャライザは呼び出されません。            </p>
          </section>


          <header>
            <h1 id="known_issues"><a href="#known_issues">既知の問題</a></h1>
          </header>

          <section>
            <h2 id="known_fastbuild_clang"><a href="#known_fastbuild_clang">Clang++ での FASTBuild</a></h2>
            <p>
              FASTBuild を Clang で使用する場合、FASTBuild はソース・ファイルの前処理中にすべての<code class="notranslate language-cpp code-in-text"><span class="token operator">-</span>I</code>コマンドライン引数を削除します。            </p>
            <p>
              これは、Clang 使用時の<a href="https://github.com/fastbuild/fastbuild/blob/178c7512ed4d3594bfad22bed967a5d557fc88b9/Code/Tools/FBuild/FBuildCore/ExeDrivers/Compiler/CompilerDriver_GCCClang.cpp#L81" target="_blank">FASTBuild のチェックが古い</a>ことが原因のようです。回避策としては、.bff スクリプトで<code class="notranslate language-cpp code-in-text"><span class="token punctuation">.</span>CompilerFamily <span class="token operator">=</span> <span class="token string">'clang'</span></code>を指定しないか、廃止されたチェックを行わずにソースから FASTBuild をビルドします。            </p>


            <h2 id="known_issues_external"><a href="#known_issues_external">'/external:I' には '/external:W' が必要です。</a></h2>
            <p>
              Visual Studio の特定のバージョンでは、<a href="https://developercommunity.visualstudio.com/t/trying-to-recompile-individual-files-with-pch-enab/1491579#T-N1618164" target="_blank">Microsoft が認めている</a>ように、ツールチェーンが外部インクルード環境を PDB ファイルに正しく格納しません。            </p>
            <p>
              この場合、<strong>/external:Iは</strong>コンパイラによって無視されるため、再コンパイル時にインクルードが見つからない可能性が高くなります。回避策としては、<a href="#project_preferences_compiler">プロジェクトの環境</a>設定で<strong>/external:W0を</strong>追加のコンパイラー・オプションとして指定してください。            </p>


            <h2 id="known_issues_include"><a href="#known_issues_include">PDBでINCLUDEが見つからない</a></h2>
            <p>
              上記のバグと同様に、Visual Studioの特定のバージョンでもINCLUDE環境がPDBファイルに取り込まれず保存されない<a href="https://developercommunity.visualstudio.com/t/trying-to-recompile-individual-files-with-pch-enab/1491579#T-N1618164" target="_blank">ことが</a>あります。            </p>
            <p>
              この場合も、再コンパイル時にインクルードが欠落することになります。回避策としては、<a href="#project_preferences_compiler">プロジェクトの環境</a>設定で、必要なインクルード・パスを追加のコンパイラー・オプションとして指定します。            </p>


            <h2 id="known_reloading_in_halted_processes"><a href="#known_reloading_in_halted_processes">停止中のプロセスでのホット・リロード</a></h2>
            <p>
              Visual Studio 2022（バージョン 17.11）で導入されたデバッガーは、CONTEXT構造体を内部的にキャッシュするようになり、<a href="https://developercommunity.visualstudio.com/t/VS2022-debugger-doesnt-adjust-RIP-corre/10801166" target="_blank">Microsoftが認めて</a>いるように、<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext" target="_blank">GetThreadContext() Win32 APIが</a>命令ポインターの偽の値を返すようになりました。            </p>
            <p>
              残念ながら、Live++は、ホットロードされたプロセスがデバッグされている間、そのプロセスの命令ポインタに関する知識に依存しています。Live++ 2.8.0では回避策が実装されていますが、無関係なWin32 APIを壊すことは、かなり影響が大きいと思われるため、マイクロソフト社にこの動作を修正するよう強く求めます。            </p>
          </section>

          <header>
            <h1 id="troubleshooting"><a href="#troubleshooting">トラブルシューティング</a></h1>
            <p class="lead">Live++の使用中に問題が発生した場合、トラブルシューティングに特化した機能がいくつかあります。</p>
          </header>

          <section>
            <h2 id="troubleshooting_missing_compilands"><a href="#troubleshooting_missing_compilands">欠落しているコンパイランド</a></h2>
            <p>
              Live++を初めてアプリケーションに統合するとき、すべてのコンパイラとリンカ・オプションが正しく設定されていなかったり、いくつかの翻訳ユニットやダイナミック・ライブラリがLive++によってロードされず、有効になっていなかったりする状況に遭遇するかもしれません。デフォルトでは、不完全な翻訳ユニットやモジュールは<strong>コンパイル単位</strong>ビューに表示されないため、どのコンパイランドがロードに失敗したかを追跡するのは難しいかもしれません。            </p>
            <p>
              この問題を解決するには、<span class="notranslate label label-default label-custom-MM">編集 -> グローバル設定... -> ホットリロード</span>、<strong>不完全なモジュールをロード</strong>と<strong>不完全なコンパイル単位をロード</strong>2つのオプションを有効にしてください。これらの設定が有効な場合、Live++は、読み込みに失敗したかどうかにかかわらず、すべての翻訳ユニットとモジュールを<strong>コンパイル単位</strong>ビューに一覧表示します。            </p>
            <p>
              <img src="assets/img/compilands_view_all_jpn.png" alt="Compilands view all">
            </p>            
            <p>
              さらに、任意の翻訳ユニットまたはモジュールを右クリックして、<span class="notranslate label label-default label-custom-MM">詳細を表示...</span>選択すると、この特定の翻訳ユニットまたはモジュールに保存されているすべての情報と、識別されたすべての不具合を表示するダイアログが表示されます：            </p>
            <p>
              <img src="assets/img/module_defects_jpn.png" alt="Module defects">
            </p>
            <p>
              <img src="assets/img/compiland_defects_jpn.png" alt="Compiland defects">
            </p>


            <h2 id="troubleshooting_verbose_compiling"><a href="#troubleshooting_verbose_compiling">詳細コンパイル</a></h2>
            <p>
              状況によっては、Live++による変更の再コンパイルに失敗することがあります。これは、プロジェクト環境設定の欠落、異常なビルド設定、またはLive++のバグが原因である可能性があります。<span class="notranslate label label-default label-custom-MM">デバッグ -> 冗長性のあるコンパイルを切り替える</span>を有効にすると、このような問題の診断に役立ちます。            </p>
            <p>
              冗長コンパイルを有効にすると、Live++は、任意のファイルを再コンパイルする際に、以下の情報を出力します：              <ul>
                <li>コンパイラ・パス</li>
                <li>コンパイラ作業ディレクトリ</li>
                <li>コンパイラのコマンドライン・オプション</li>
                <li>インクルードされたファイル</li>
              </ul>
              さらに、使用するツールチェーンでサポートされている場合は、冗長モードでコンパイルが実行されます。            </p>


            <h2 id="troubleshooting_verbose_linking"><a href="#troubleshooting_verbose_linking">冗長リンク</a></h2>
            <p>
              冗長コンパイルと同様に、<span class="notranslate label label-default label-custom-MM">デバッグ -> 冗長性のあるリンクを切り替える</span>ある冗長リンクは、Live++がパッチのリンクに失敗する可能性のある問題を診断するのに役立ちます。 
            </p>
            <p>
              冗長リンクを有効にすると、Live++はパッチをリンクするときに以下の情報を出力します：              <ul>
                <li>リンカ・パス</li>
                <li>リンカの作業ディレクトリ</li>
                <li>リンカ・コマンド行オプション</li>
              </ul>
              さらに、使用するツールチェーンでサポートされている場合、リンクは冗長モードで実行され、パッチに取り込まれる翻訳ユニットだけでなく、使用される静的ライブラリも出力されます。            </p>
          </section>


          <header>
            <h1 id="3rd_party_libraries"><a href="#3rd_party_libraries">サードパーティライブラリ</a></h1>
          </header>

          <section>
            <pre class="notranslate">json.h

This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to http://unlicense.org/
            </pre>

            <pre class="notranslate">Intel® X86 Encoder Decoder (Intel® XED)

Copyright (c) 2023 Intel Corporation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
            </pre>

            <pre class="notranslate">xxHash Library
Copyright (c) 2012-2020 Yann Collet
All rights reserved.

BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this
  list of conditions and the following disclaimer in the documentation and/or
  other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.       
            </pre>
          </section>
        </main>
    </div>
</body>
</html>